From 4f5530f529889cf984c620c882e269df3e301046 Mon Sep 17 00:00:00 2001
From: Julian Andres Klode <julian.klode@canonical.com>
Date: Fri, 9 Dec 2022 15:53:48 +0100
Subject: Cherry-pick all the 2.12 memory management changes

This has been tested successfully against 1115MB large initrds
in a kvm

LP: #1842320
---
 .../2.12-mm/0194-mm-Clarify-grub_real_malloc.patch | 181 ++++++
 ...l_malloc-Make-small-allocs-comment-match-.patch |  30 +
 .../2.12-mm/0196-mm-Document-grub_free.patch       | 118 ++++
 .../0197-mm-Document-grub_mm_init_region.patch     |  71 +++
 .../0198-kern-Remove-trailing-whitespaces.patch    | 674 +++++++++++++++++++++
 ...-GRUB-internal-memory-management-structur.patch |  76 +++
 ...hat-we-preserve-header-vs-region-alignmen.patch |  54 ++
 ...ing-a-region-merge-with-region-after-as-w.patch | 201 ++++++
 ...02-mm-Debug-support-for-region-operations.patch |  69 +++
 ...m-Drop-unused-unloading-of-modules-on-OOM.patch |  78 +++
 ...namically-requesting-additional-memory-re.patch | 128 ++++
 ...-Always-request-a-fixed-number-of-pages-o.patch | 101 +++
 ...mm-Extract-function-to-add-memory-regions.patch |  82 +++
 ...mm-Pass-up-errors-from-add_memory_regions.patch |  85 +++
 ...fi-mm-Implement-runtime-addition-of-pages.patch |  73 +++
 ...rease-default-memory-allocation-to-32-MiB.patch |  29 +
 ...lidate-disk-caches-last-when-out-of-memor.patch |  55 ++
 debian/patches/series                              |  17 +
 18 files changed, 2122 insertions(+)
 create mode 100644 debian/patches/2.12-mm/0194-mm-Clarify-grub_real_malloc.patch
 create mode 100644 debian/patches/2.12-mm/0195-mm-grub_real_malloc-Make-small-allocs-comment-match-.patch
 create mode 100644 debian/patches/2.12-mm/0196-mm-Document-grub_free.patch
 create mode 100644 debian/patches/2.12-mm/0197-mm-Document-grub_mm_init_region.patch
 create mode 100644 debian/patches/2.12-mm/0198-kern-Remove-trailing-whitespaces.patch
 create mode 100644 debian/patches/2.12-mm/0199-mm-Document-GRUB-internal-memory-management-structur.patch
 create mode 100644 debian/patches/2.12-mm/0200-mm-Assert-that-we-preserve-header-vs-region-alignmen.patch
 create mode 100644 debian/patches/2.12-mm/0201-mm-When-adding-a-region-merge-with-region-after-as-w.patch
 create mode 100644 debian/patches/2.12-mm/0202-mm-Debug-support-for-region-operations.patch
 create mode 100644 debian/patches/2.12-mm/0203-mm-Drop-unused-unloading-of-modules-on-OOM.patch
 create mode 100644 debian/patches/2.12-mm/0204-mm-Allow-dynamically-requesting-additional-memory-re.patch
 create mode 100644 debian/patches/2.12-mm/0205-kern-efi-mm-Always-request-a-fixed-number-of-pages-o.patch
 create mode 100644 debian/patches/2.12-mm/0206-kern-efi-mm-Extract-function-to-add-memory-regions.patch
 create mode 100644 debian/patches/2.12-mm/0207-kern-efi-mm-Pass-up-errors-from-add_memory_regions.patch
 create mode 100644 debian/patches/2.12-mm/0208-kern-efi-mm-Implement-runtime-addition-of-pages.patch
 create mode 100644 debian/patches/2.12-mm/0209-efi-Increase-default-memory-allocation-to-32-MiB.patch
 create mode 100644 debian/patches/2.12-mm/0210-mm-Try-invalidate-disk-caches-last-when-out-of-memor.patch

diff --git a/debian/patches/2.12-mm/0194-mm-Clarify-grub_real_malloc.patch b/debian/patches/2.12-mm/0194-mm-Clarify-grub_real_malloc.patch
new file mode 100644
index 0000000..dbde9fd
--- /dev/null
+++ b/debian/patches/2.12-mm/0194-mm-Clarify-grub_real_malloc.patch
@@ -0,0 +1,181 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 25 Nov 2021 02:22:46 +1100
+Subject: mm: Clarify grub_real_malloc()
+
+When iterating through the singly linked list of free blocks,
+grub_real_malloc() uses p and q for the current and previous blocks
+respectively. This isn't super clear, so swap to using prev and cur.
+
+This makes another quirk more obvious. The comment at the top of
+grub_real_malloc() might lead you to believe that the function will
+allocate from *first if there is space in that block.
+
+It actually doesn't do that, and it can't do that with the current
+data structures. If we used up all of *first, we would need to change
+the ->next of the previous block to point to *first->next, but we
+can't do that because it's a singly linked list and we don't have
+access to *first's previous block.
+
+What grub_real_malloc() actually does is set *first to the initial
+previous block, and *first->next is the block we try to allocate
+from. That allows us to keep all the data structures consistent.
+
+Document that.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/mm.c | 76 +++++++++++++++++++++++++++++------------------------
+ 1 file changed, 41 insertions(+), 35 deletions(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index c070afc..6efabe9 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -178,13 +178,20 @@ grub_mm_init_region (void *addr, grub_size_t size)
+ }
+ 
+ /* Allocate the number of units N with the alignment ALIGN from the ring
+-   buffer starting from *FIRST.  ALIGN must be a power of two. Both N and
+-   ALIGN are in units of GRUB_MM_ALIGN.  Return a non-NULL if successful,
+-   otherwise return NULL.  */
++ * buffer given in *FIRST.  ALIGN must be a power of two. Both N and
++ * ALIGN are in units of GRUB_MM_ALIGN.  Return a non-NULL if successful,
++ * otherwise return NULL.
++ *
++ * Note: because in certain circumstances we need to adjust the ->next
++ * pointer of the previous block, we iterate over the singly linked
++ * list with the pair (prev, cur). *FIRST is our initial previous, and
++ * *FIRST->next is our initial current pointer. So we will actually
++ * allocate from *FIRST->next first and *FIRST itself last.
++ */
+ static void *
+ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ {
+-  grub_mm_header_t p, q;
++  grub_mm_header_t cur, prev;
+ 
+   /* When everything is allocated side effect is that *first will have alloc
+      magic marked, meaning that there is no room in this region.  */
+@@ -192,24 +199,24 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+     return 0;
+ 
+   /* Try to search free slot for allocation in this memory region.  */
+-  for (q = *first, p = q->next; ; q = p, p = p->next)
++  for (prev = *first, cur = prev->next; ; prev = cur, cur = cur->next)
+     {
+       grub_off_t extra;
+ 
+-      extra = ((grub_addr_t) (p + 1) >> GRUB_MM_ALIGN_LOG2) & (align - 1);
++      extra = ((grub_addr_t) (cur + 1) >> GRUB_MM_ALIGN_LOG2) & (align - 1);
+       if (extra)
+ 	extra = align - extra;
+ 
+-      if (! p)
++      if (! cur)
+ 	grub_fatal ("null in the ring");
+ 
+-      if (p->magic != GRUB_MM_FREE_MAGIC)
+-	grub_fatal ("free magic is broken at %p: 0x%x", p, p->magic);
++      if (cur->magic != GRUB_MM_FREE_MAGIC)
++	grub_fatal ("free magic is broken at %p: 0x%x", cur, cur->magic);
+ 
+-      if (p->size >= n + extra)
++      if (cur->size >= n + extra)
+ 	{
+-	  extra += (p->size - extra - n) & (~(align - 1));
+-	  if (extra == 0 && p->size == n)
++	  extra += (cur->size - extra - n) & (~(align - 1));
++	  if (extra == 0 && cur->size == n)
+ 	    {
+ 	      /* There is no special alignment requirement and memory block
+ 	         is complete match.
+@@ -222,9 +229,9 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ 	         | alloc, size=n |          |
+ 	         +---------------+          v
+ 	       */
+-	      q->next = p->next;
++	      prev->next = cur->next;
+ 	    }
+-	  else if (align == 1 || p->size == n + extra)
++	  else if (align == 1 || cur->size == n + extra)
+ 	    {
+ 	      /* There might be alignment requirement, when taking it into
+ 	         account memory block fits in.
+@@ -241,23 +248,22 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ 	         | alloc, size=n |        |
+ 	         +---------------+        v
+ 	       */
+-
+-	      p->size -= n;
+-	      p += p->size;
++	      cur->size -= n;
++	      cur += cur->size;
+ 	    }
+ 	  else if (extra == 0)
+ 	    {
+ 	      grub_mm_header_t r;
+ 	      
+-	      r = p + extra + n;
++	      r = cur + extra + n;
+ 	      r->magic = GRUB_MM_FREE_MAGIC;
+-	      r->size = p->size - extra - n;
+-	      r->next = p->next;
+-	      q->next = r;
++	      r->size = cur->size - extra - n;
++	      r->next = cur->next;
++	      prev->next = r;
+ 
+-	      if (q == p)
++	      if (prev == cur)
+ 		{
+-		  q = r;
++		  prev = r;
+ 		  r->next = r;
+ 		}
+ 	    }
+@@ -284,32 +290,32 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ 	       */
+ 	      grub_mm_header_t r;
+ 
+-	      r = p + extra + n;
++	      r = cur + extra + n;
+ 	      r->magic = GRUB_MM_FREE_MAGIC;
+-	      r->size = p->size - extra - n;
+-	      r->next = p;
++	      r->size = cur->size - extra - n;
++	      r->next = cur;
+ 
+-	      p->size = extra;
+-	      q->next = r;
+-	      p += extra;
++	      cur->size = extra;
++	      prev->next = r;
++	      cur += extra;
+ 	    }
+ 
+-	  p->magic = GRUB_MM_ALLOC_MAGIC;
+-	  p->size = n;
++	  cur->magic = GRUB_MM_ALLOC_MAGIC;
++	  cur->size = n;
+ 
+ 	  /* Mark find as a start marker for next allocation to fasten it.
+ 	     This will have side effect of fragmenting memory as small
+ 	     pieces before this will be un-used.  */
+ 	  /* So do it only for chunks under 64K.  */
+ 	  if (n < (0x8000 >> GRUB_MM_ALIGN_LOG2)
+-	      || *first == p)
+-	    *first = q;
++	      || *first == cur)
++	    *first = prev;
+ 
+-	  return p + 1;
++	  return cur + 1;
+ 	}
+ 
+       /* Search was completed without result.  */
+-      if (p == *first)
++      if (cur == *first)
+ 	break;
+     }
+ 
diff --git a/debian/patches/2.12-mm/0195-mm-grub_real_malloc-Make-small-allocs-comment-match-.patch b/debian/patches/2.12-mm/0195-mm-grub_real_malloc-Make-small-allocs-comment-match-.patch
new file mode 100644
index 0000000..47b0468
--- /dev/null
+++ b/debian/patches/2.12-mm/0195-mm-grub_real_malloc-Make-small-allocs-comment-match-.patch
@@ -0,0 +1,30 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 25 Nov 2021 02:22:47 +1100
+Subject: mm: grub_real_malloc(): Make small allocs comment match code
+
+Small allocations move the region's *first pointer. The comment
+says that this happens for allocations under 64K. The code says
+it's for allocations under 32K. Commit 45bf8b3a7549 changed the
+code intentionally: make the comment match.
+
+Fixes: 45bf8b3a7549 (* grub-core/kern/mm.c (grub_real_malloc): Decrease cut-off of moving the)
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/mm.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index 6efabe9..ac41cf4 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -306,7 +306,7 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ 	  /* Mark find as a start marker for next allocation to fasten it.
+ 	     This will have side effect of fragmenting memory as small
+ 	     pieces before this will be un-used.  */
+-	  /* So do it only for chunks under 64K.  */
++	  /* So do it only for chunks under 32K.  */
+ 	  if (n < (0x8000 >> GRUB_MM_ALIGN_LOG2)
+ 	      || *first == cur)
+ 	    *first = prev;
diff --git a/debian/patches/2.12-mm/0196-mm-Document-grub_free.patch b/debian/patches/2.12-mm/0196-mm-Document-grub_free.patch
new file mode 100644
index 0000000..1c0e5ea
--- /dev/null
+++ b/debian/patches/2.12-mm/0196-mm-Document-grub_free.patch
@@ -0,0 +1,118 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 25 Nov 2021 02:22:48 +1100
+Subject: mm: Document grub_free()
+
+The grub_free() possesses a surprising number of quirks, and also
+uses single-letter variable names confusingly to iterate through
+the free list.
+
+Document what's going on.
+
+Use prev and cur to iterate over the free list.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/mm.c | 63 ++++++++++++++++++++++++++++++++++-------------------
+ 1 file changed, 41 insertions(+), 22 deletions(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index ac41cf4..bec960c 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -446,54 +446,73 @@ grub_free (void *ptr)
+     }
+   else
+     {
+-      grub_mm_header_t q, s;
++      grub_mm_header_t cur, prev;
+ 
+ #if 0
+-      q = r->first;
++      cur = r->first;
+       do
+ 	{
+ 	  grub_printf ("%s:%d: q=%p, q->size=0x%x, q->magic=0x%x\n",
+-		       GRUB_FILE, __LINE__, q, q->size, q->magic);
+-	  q = q->next;
++		       GRUB_FILE, __LINE__, cur, cur->size, cur->magic);
++	  cur = cur->next;
+ 	}
+-      while (q != r->first);
++      while (cur != r->first);
+ #endif
+-
+-      for (s = r->first, q = s->next; q <= p || q->next >= p; s = q, q = s->next)
++      /* Iterate over all blocks in the free ring.
++       *
++       * The free ring is arranged from high addresses to low
++       * addresses, modulo wraparound.
++       *
++       * We are looking for a block with a higher address than p or
++       * whose next address is lower than p.
++       */
++      for (prev = r->first, cur = prev->next; cur <= p || cur->next >= p;
++	   prev = cur, cur = prev->next)
+ 	{
+-	  if (q->magic != GRUB_MM_FREE_MAGIC)
+-	    grub_fatal ("free magic is broken at %p: 0x%x", q, q->magic);
++	  if (cur->magic != GRUB_MM_FREE_MAGIC)
++	    grub_fatal ("free magic is broken at %p: 0x%x", cur, cur->magic);
+ 
+-	  if (q <= q->next && (q > p || q->next < p))
++	  /* Deal with wrap-around */
++	  if (cur <= cur->next && (cur > p || cur->next < p))
+ 	    break;
+ 	}
+ 
++      /* mark p as free and insert it between cur and cur->next */
+       p->magic = GRUB_MM_FREE_MAGIC;
+-      p->next = q->next;
+-      q->next = p;
++      p->next = cur->next;
++      cur->next = p;
+ 
++      /*
++       * If the block we are freeing can be merged with the next
++       * free block, do that.
++       */
+       if (p->next + p->next->size == p)
+ 	{
+ 	  p->magic = 0;
+ 
+ 	  p->next->size += p->size;
+-	  q->next = p->next;
++	  cur->next = p->next;
+ 	  p = p->next;
+ 	}
+ 
+-      r->first = q;
++      r->first = cur;
+ 
+-      if (q == p + p->size)
++      /* Likewise if can be merged with the preceeding free block */
++      if (cur == p + p->size)
+ 	{
+-	  q->magic = 0;
+-	  p->size += q->size;
+-	  if (q == s)
+-	    s = p;
+-	  s->next = p;
+-	  q = s;
++	  cur->magic = 0;
++	  p->size += cur->size;
++	  if (cur == prev)
++	    prev = p;
++	  prev->next = p;
++	  cur = prev;
+ 	}
+ 
+-      r->first = q;
++      /*
++       * Set r->first such that the just free()d block is tried first.
++       * (An allocation is tried from *first->next, and cur->next == p.)
++       */
++      r->first = cur;
+     }
+ }
+ 
diff --git a/debian/patches/2.12-mm/0197-mm-Document-grub_mm_init_region.patch b/debian/patches/2.12-mm/0197-mm-Document-grub_mm_init_region.patch
new file mode 100644
index 0000000..5b36ebe
--- /dev/null
+++ b/debian/patches/2.12-mm/0197-mm-Document-grub_mm_init_region.patch
@@ -0,0 +1,71 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 25 Nov 2021 02:22:49 +1100
+Subject: mm: Document grub_mm_init_region()
+
+The grub_mm_init_region() does some things that seem magical, especially
+around region merging. Make it a bit clearer.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/mm.c | 31 ++++++++++++++++++++++++++++++-
+ 1 file changed, 30 insertions(+), 1 deletion(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index bec960c..c686917 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -128,23 +128,52 @@ grub_mm_init_region (void *addr, grub_size_t size)
+   if (((grub_addr_t) addr + 0x1000) > ~(grub_addr_t) size)
+     size = ((grub_addr_t) -0x1000) - (grub_addr_t) addr;
+ 
++  /* Attempt to merge this region with every existing region */
+   for (p = &grub_mm_base, q = *p; q; p = &(q->next), q = *p)
++    /*
++     * Is the new region immediately below an existing region? That
++     * is, is the address of the memory we're adding now (addr) + size
++     * of the memory we're adding (size) + the bytes we couldn't use
++     * at the start of the region we're considering (q->pre_size)
++     * equal to the address of q? In other words, does the memory
++     * looks like this?
++     *
++     * addr                          q
++     *   |----size-----|-q->pre_size-|<q region>|
++     */
+     if ((grub_uint8_t *) addr + size + q->pre_size == (grub_uint8_t *) q)
+       {
++	/*
++	 * Yes, we can merge the memory starting at addr into the
++	 * existing region from below. Align up addr to GRUB_MM_ALIGN
++	 * so that our new region has proper alignment.
++	 */
+ 	r = (grub_mm_region_t) ALIGN_UP ((grub_addr_t) addr, GRUB_MM_ALIGN);
++	/* Copy the region data across */
+ 	*r = *q;
++	/* Consider all the new size as pre-size */
+ 	r->pre_size += size;
+-	
++
++	/*
++	 * If we have enough pre-size to create a block, create a
++	 * block with it. Mark it as allocated and pass it to
++	 * grub_free (), which will sort out getting it into the free
++	 * list.
++	 */
+ 	if (r->pre_size >> GRUB_MM_ALIGN_LOG2)
+ 	  {
+ 	    h = (grub_mm_header_t) (r + 1);
++	    /* block size is pre-size converted to cells */
+ 	    h->size = (r->pre_size >> GRUB_MM_ALIGN_LOG2);
+ 	    h->magic = GRUB_MM_ALLOC_MAGIC;
++	    /* region size grows by block size converted back to bytes */
+ 	    r->size += h->size << GRUB_MM_ALIGN_LOG2;
++	    /* adjust pre_size to be accurate */
+ 	    r->pre_size &= (GRUB_MM_ALIGN - 1);
+ 	    *p = r;
+ 	    grub_free (h + 1);
+ 	  }
++	/* Replace the old region with the new region */
+ 	*p = r;
+ 	return;
+       }
diff --git a/debian/patches/2.12-mm/0198-kern-Remove-trailing-whitespaces.patch b/debian/patches/2.12-mm/0198-kern-Remove-trailing-whitespaces.patch
new file mode 100644
index 0000000..3555ff8
--- /dev/null
+++ b/debian/patches/2.12-mm/0198-kern-Remove-trailing-whitespaces.patch
@@ -0,0 +1,674 @@
+From: Elyes Haouas <ehaouas@noos.fr>
+Date: Fri, 4 Mar 2022 07:42:03 +0100
+Subject: kern: Remove trailing whitespaces
+
+Signed-off-by: Elyes Haouas <ehaouas@noos.fr>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/acpi.c                | 2 +-
+ grub-core/kern/arm/efi/init.c        | 2 +-
+ grub-core/kern/arm64/dl.c            | 2 +-
+ grub-core/kern/arm64/dl_helper.c     | 4 ++--
+ grub-core/kern/command.c             | 2 +-
+ grub-core/kern/coreboot/cbtable.c    | 2 +-
+ grub-core/kern/device.c              | 2 +-
+ grub-core/kern/disk.c                | 6 +++---
+ grub-core/kern/dl.c                  | 2 +-
+ grub-core/kern/efi/efi.c             | 2 +-
+ grub-core/kern/efi/init.c            | 2 +-
+ grub-core/kern/efi/mm.c              | 2 +-
+ grub-core/kern/emu/hostdisk.c        | 2 +-
+ grub-core/kern/emu/hostfs.c          | 2 +-
+ grub-core/kern/emu/main.c            | 2 +-
+ grub-core/kern/emu/misc.c            | 8 ++++----
+ grub-core/kern/env.c                 | 4 ++--
+ grub-core/kern/file.c                | 4 ++--
+ grub-core/kern/i386/coreboot/init.c  | 2 +-
+ grub-core/kern/i386/pc/mmap.c        | 8 ++++----
+ grub-core/kern/i386/qemu/init.c      | 4 ++--
+ grub-core/kern/ia64/dl_helper.c      | 6 +++---
+ grub-core/kern/ieee1275/ieee1275.c   | 2 +-
+ grub-core/kern/ieee1275/init.c       | 6 +++---
+ grub-core/kern/ieee1275/openfw.c     | 2 +-
+ grub-core/kern/main.c                | 4 ++--
+ grub-core/kern/mips/dl.c             | 8 ++++----
+ grub-core/kern/mips/loongson/init.c  | 6 +++---
+ grub-core/kern/mips/qemu_mips/init.c | 4 ++--
+ grub-core/kern/misc.c                | 4 ++--
+ grub-core/kern/mm.c                  | 4 ++--
+ grub-core/kern/partition.c           | 2 +-
+ grub-core/kern/powerpc/dl.c          | 8 ++++----
+ 33 files changed, 61 insertions(+), 61 deletions(-)
+
+diff --git a/grub-core/kern/acpi.c b/grub-core/kern/acpi.c
+index 5746ac0..70898dd 100644
+--- a/grub-core/kern/acpi.c
++++ b/grub-core/kern/acpi.c
+@@ -1,4 +1,4 @@
+-/* 
++/*
+  *  GRUB  --  GRand Unified Bootloader
+  *  Copyright (C) 2012  Free Software Foundation, Inc.
+  *
+diff --git a/grub-core/kern/arm/efi/init.c b/grub-core/kern/arm/efi/init.c
+index 40c3b46..7fcf91b 100644
+--- a/grub-core/kern/arm/efi/init.c
++++ b/grub-core/kern/arm/efi/init.c
+@@ -34,7 +34,7 @@ grub_efi_get_time_ms (void)
+   return tmr;
+ }
+ 
+-static void 
++static void
+ increment_timer (grub_efi_event_t event __attribute__ ((unused)),
+ 		 void *context __attribute__ ((unused)))
+ {
+diff --git a/grub-core/kern/arm64/dl.c b/grub-core/kern/arm64/dl.c
+index 512e5a8..a2b5789 100644
+--- a/grub-core/kern/arm64/dl.c
++++ b/grub-core/kern/arm64/dl.c
+@@ -49,7 +49,7 @@ grub_arch_dl_check_header (void *ehdr)
+ #pragma GCC diagnostic ignored "-Wcast-align"
+ 
+ /*
+- * Unified function for both REL and RELA 
++ * Unified function for both REL and RELA
+  */
+ grub_err_t
+ grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+diff --git a/grub-core/kern/arm64/dl_helper.c b/grub-core/kern/arm64/dl_helper.c
+index e00c198..cf7d432 100644
+--- a/grub-core/kern/arm64/dl_helper.c
++++ b/grub-core/kern/arm64/dl_helper.c
+@@ -69,9 +69,9 @@ grub_arm64_set_hi21 (grub_uint32_t *place, grub_int64_t offset)
+   grub_uint32_t val;
+ 
+   offset >>= 12;
+-  
++
+   val = ((offset & 3) << 29) | (((offset >> 2) & 0x7ffff) << 5);
+-  
++
+   *place &= insmask;
+   *place |= grub_cpu_to_le32 (val) & ~insmask;
+ }
+diff --git a/grub-core/kern/command.c b/grub-core/kern/command.c
+index 4aabcd4..5812e13 100644
+--- a/grub-core/kern/command.c
++++ b/grub-core/kern/command.c
+@@ -46,7 +46,7 @@ grub_register_command_prio (const char *name,
+ 
+   cmd->flags = 0;
+   cmd->prio = prio;
+-    
++
+   for (p = &grub_command_list, q = *p; q; p = &(q->next), q = q->next)
+     {
+       int r;
+diff --git a/grub-core/kern/coreboot/cbtable.c b/grub-core/kern/coreboot/cbtable.c
+index aec63db..b6d0801 100644
+--- a/grub-core/kern/coreboot/cbtable.c
++++ b/grub-core/kern/coreboot/cbtable.c
+@@ -62,7 +62,7 @@ signature_found:
+        {
+          table_header = (grub_linuxbios_table_header_t) (grub_addr_t)
+            *(grub_uint64_t *) (table_item + 1);
+-         goto signature_found;   
++         goto signature_found;
+        }
+       if (hook (table_item, hook_data))
+        return 1;
+diff --git a/grub-core/kern/device.c b/grub-core/kern/device.c
+index 73b8ecc..92ce8a7 100644
+--- a/grub-core/kern/device.c
++++ b/grub-core/kern/device.c
+@@ -56,7 +56,7 @@ grub_device_open (const char *name)
+   if (grub_net_open && grub_errno == GRUB_ERR_UNKNOWN_DEVICE)
+     {
+       grub_errno = GRUB_ERR_NONE;
+-      dev->net = grub_net_open (name); 
++      dev->net = grub_net_open (name);
+     }
+ 
+   if (dev->net)
+diff --git a/grub-core/kern/disk.c b/grub-core/kern/disk.c
+index e1b0e07..3a42c00 100644
+--- a/grub-core/kern/disk.c
++++ b/grub-core/kern/disk.c
+@@ -376,7 +376,7 @@ grub_disk_read_small_real (grub_disk_t disk, grub_disk_addr_t sector,
+     tmp_buf = grub_malloc (num << disk->log_sector_size);
+     if (!tmp_buf)
+       return grub_errno;
+-    
++
+     if ((disk->dev->disk_read) (disk, transform_sector (disk, aligned_sector),
+ 				num, tmp_buf))
+       {
+@@ -490,7 +490,7 @@ grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,
+ 					buf);
+ 	  if (err)
+ 	    return err;
+-	  
++
+ 	  for (i = 0; i < agglomerate; i ++)
+ 	    grub_disk_cache_store (disk->dev->id, disk->id,
+ 				   sector + (i << GRUB_DISK_CACHE_BITS),
+@@ -505,7 +505,7 @@ grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,
+ 
+ 	  sector += agglomerate << GRUB_DISK_CACHE_BITS;
+ 	  size -= agglomerate << (GRUB_DISK_CACHE_BITS + GRUB_DISK_SECTOR_BITS);
+-	  buf = (char *) buf 
++	  buf = (char *) buf
+ 	    + (agglomerate << (GRUB_DISK_CACHE_BITS + GRUB_DISK_SECTOR_BITS));
+ 	}
+ 
+diff --git a/grub-core/kern/dl.c b/grub-core/kern/dl.c
+index 1fea604..b3e93c3 100644
+--- a/grub-core/kern/dl.c
++++ b/grub-core/kern/dl.c
+@@ -480,7 +480,7 @@ grub_dl_resolve_name (grub_dl_t mod, Elf_Ehdr *e)
+   s = grub_dl_find_section (e, ".modname");
+   if (!s)
+     return grub_error (GRUB_ERR_BAD_MODULE, "no module name found");
+-  
++
+   mod->name = grub_strdup ((char *) e + s->sh_offset);
+   if (! mod->name)
+     return grub_errno;
+diff --git a/grub-core/kern/efi/efi.c b/grub-core/kern/efi/efi.c
+index 69c283d..4795fe9 100644
+--- a/grub-core/kern/efi/efi.c
++++ b/grub-core/kern/efi/efi.c
+@@ -228,7 +228,7 @@ grub_efi_set_variable(const char *var, const grub_efi_guid_t *guid,
+ 
+   r = grub_efi_system_table->runtime_services;
+ 
+-  status = efi_call_5 (r->set_variable, var16, guid, 
++  status = efi_call_5 (r->set_variable, var16, guid,
+ 		       (GRUB_EFI_VARIABLE_NON_VOLATILE
+ 			| GRUB_EFI_VARIABLE_BOOTSERVICE_ACCESS
+ 			| GRUB_EFI_VARIABLE_RUNTIME_ACCESS),
+diff --git a/grub-core/kern/efi/init.c b/grub-core/kern/efi/init.c
+index 7facacf..26ed07b 100644
+--- a/grub-core/kern/efi/init.c
++++ b/grub-core/kern/efi/init.c
+@@ -111,7 +111,7 @@ grub_efi_init (void)
+   grub_efidisk_init ();
+ }
+ 
+-void (*grub_efi_net_config) (grub_efi_handle_t hnd, 
++void (*grub_efi_net_config) (grub_efi_handle_t hnd,
+ 			     char **device,
+ 			     char **path);
+ 
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index 7741d66..dac9c58 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -554,7 +554,7 @@ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+ 
+       addr = grub_efi_allocate_pages_real (start, pages,
+ 					   GRUB_EFI_ALLOCATE_ADDRESS,
+-					   GRUB_EFI_LOADER_CODE);      
++					   GRUB_EFI_LOADER_CODE);
+       if (! addr)
+ 	grub_fatal ("cannot allocate conventional memory %p with %u pages",
+ 		    (void *) ((grub_addr_t) start),
+diff --git a/grub-core/kern/emu/hostdisk.c b/grub-core/kern/emu/hostdisk.c
+index f90b6c9..3e39fc6 100644
+--- a/grub-core/kern/emu/hostdisk.c
++++ b/grub-core/kern/emu/hostdisk.c
+@@ -550,7 +550,7 @@ read_device_map (const char *dev_map)
+       map[drive].device = grub_canonicalize_file_name (p);
+       if (! map[drive].device)
+ 	map[drive].device = xstrdup (p);
+-      
++
+       if (!map[drive].drive)
+ 	{
+ 	  char c;
+diff --git a/grub-core/kern/emu/hostfs.c b/grub-core/kern/emu/hostfs.c
+index cb53210..ccbe13f 100644
+--- a/grub-core/kern/emu/hostfs.c
++++ b/grub-core/kern/emu/hostfs.c
+@@ -122,7 +122,7 @@ grub_hostfs_open (struct grub_file *file, const char *name)
+       return grub_errno;
+     }
+ 
+-  data->f = f;  
++  data->f = f;
+ 
+   file->data = data;
+ 
+diff --git a/grub-core/kern/emu/main.c b/grub-core/kern/emu/main.c
+index 55ea5a1..65d5ea6 100644
+--- a/grub-core/kern/emu/main.c
++++ b/grub-core/kern/emu/main.c
+@@ -194,7 +194,7 @@ int
+ main (int argc, char *argv[])
+ {
+   struct arguments arguments =
+-    { 
++    {
+       .dev_map = DEFAULT_DEVICE_MAP,
+       .hold = 0,
+       .mem_disk = 0,
+diff --git a/grub-core/kern/emu/misc.c b/grub-core/kern/emu/misc.c
+index 0ff13bc..45cd270 100644
+--- a/grub-core/kern/emu/misc.c
++++ b/grub-core/kern/emu/misc.c
+@@ -135,16 +135,16 @@ xstrdup (const char *str)
+ #if !defined (GRUB_MKFONT) && !defined (GRUB_BUILD)
+ char *
+ xasprintf (const char *fmt, ...)
+-{ 
++{
+   va_list ap;
+   char *result;
+-  
++
+   va_start (ap, fmt);
+   result = grub_xvasprintf (fmt, ap);
+   va_end (ap);
+   if (!result)
+     grub_util_error ("%s", _("out of memory"));
+-  
++
+   return result;
+ }
+ #endif
+@@ -181,7 +181,7 @@ grub_util_get_image_size (const char *path)
+     grub_util_error (_("cannot open `%s': %s"), path, strerror (errno));
+ 
+   fseeko (f, 0, SEEK_END);
+-  
++
+   sz = ftello (f);
+   if (sz < 0)
+     grub_util_error (_("cannot open `%s': %s"), path, strerror (errno));
+diff --git a/grub-core/kern/env.c b/grub-core/kern/env.c
+index c408626..10e08ad 100644
+--- a/grub-core/kern/env.c
++++ b/grub-core/kern/env.c
+@@ -226,12 +226,12 @@ grub_env_export (const char *name)
+   if (! var)
+     {
+       grub_err_t err;
+-      
++
+       err = grub_env_set (name, "");
+       if (err)
+ 	return err;
+       var = grub_env_find (name);
+-    }    
++    }
+   var->global = 1;
+ 
+   return GRUB_ERR_NONE;
+diff --git a/grub-core/kern/file.c b/grub-core/kern/file.c
+index ffdcaba..8d48fd5 100644
+--- a/grub-core/kern/file.c
++++ b/grub-core/kern/file.c
+@@ -212,9 +212,9 @@ grub_file_seek (grub_file_t file, grub_off_t offset)
+ 		  N_("attempt to seek outside of the file"));
+       return -1;
+     }
+-  
++
+   old = file->offset;
+   file->offset = offset;
+-    
++
+   return old;
+ }
+diff --git a/grub-core/kern/i386/coreboot/init.c b/grub-core/kern/i386/coreboot/init.c
+index 36f9134..feaf929 100644
+--- a/grub-core/kern/i386/coreboot/init.c
++++ b/grub-core/kern/i386/coreboot/init.c
+@@ -77,7 +77,7 @@ heap_init (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+ 
+   if (modend && begin < modend)
+     begin = modend;
+-  
++
+   if (end <= begin)
+     return 0;
+ 
+diff --git a/grub-core/kern/i386/pc/mmap.c b/grub-core/kern/i386/pc/mmap.c
+index c0c3c35..ef2faa2 100644
+--- a/grub-core/kern/i386/pc/mmap.c
++++ b/grub-core/kern/i386/pc/mmap.c
+@@ -73,9 +73,9 @@ grub_get_ext_memsize (void)
+    in 1KB parts, and upper 16 bits are above 16MB in 64KB parts. If error, return zero.
+    BIOS call "INT 15H, AH=E801H" to get EISA memory map,
+      AX = memory between 1M and 16M in 1K parts.
+-     BX = memory above 16M in 64K parts. 
++     BX = memory above 16M in 64K parts.
+ */
+- 
++
+ static inline grub_uint32_t
+ grub_get_eisa_mmap (void)
+ {
+@@ -114,7 +114,7 @@ grub_get_mmap_entry (struct grub_machine_mmap_entry *entry,
+   /* place address (+4) in ES:DI */
+   regs.es = ((grub_addr_t) &entry->addr) >> 4;
+   regs.edi = ((grub_addr_t) &entry->addr) & 0xf;
+-	
++
+   /* set continuation value */
+   regs.ebx = cont;
+ 
+@@ -127,7 +127,7 @@ grub_get_mmap_entry (struct grub_machine_mmap_entry *entry,
+   regs.eax = 0xe820;
+   grub_bios_interrupt (0x15, &regs);
+ 
+-  /* write length of buffer (zero if error) into ADDR */	
++  /* write length of buffer (zero if error) into ADDR */
+   if ((regs.flags & GRUB_CPU_INT_FLAGS_CARRY) || regs.eax != 0x534d4150
+       || regs.ecx < 0x14 || regs.ecx > 0x400)
+     entry->size = 0;
+diff --git a/grub-core/kern/i386/qemu/init.c b/grub-core/kern/i386/qemu/init.c
+index 9fafe98..d8b48ef 100644
+--- a/grub-core/kern/i386/qemu/init.c
++++ b/grub-core/kern/i386/qemu/init.c
+@@ -174,7 +174,7 @@ enable_cards (grub_pci_device_t dev,
+ 
+   if (class == GRUB_PCI_CLASS_SUBCLASS_USB)
+     return 0;
+-  
++
+   addr = grub_pci_make_address (dev, GRUB_PCI_REG_COMMAND);
+   grub_pci_write (addr, cmd);
+ 
+@@ -237,7 +237,7 @@ grub_pci_assign_addresses (void)
+ 					      + 4 * resources[i].bar + 4);
+ 		grub_pci_write (addr, 0);
+ 	      }
+-	  }	  
++	  }
+       }
+     grub_pci_iterate (enable_cards, NULL);
+   }
+diff --git a/grub-core/kern/ia64/dl_helper.c b/grub-core/kern/ia64/dl_helper.c
+index c601595..05a0a68 100644
+--- a/grub-core/kern/ia64/dl_helper.c
++++ b/grub-core/kern/ia64/dl_helper.c
+@@ -73,7 +73,7 @@ grub_ia64_add_value_to_slot_20b (grub_addr_t addr, grub_uint32_t value)
+     case 0:
+       val = grub_le_to_cpu32 (grub_get_unaligned32 (((grub_uint8_t *)
+ 						     (addr & MASK3) + 2)));
+-      val = (((((val & MASK20) + value) & MASK20) << 2) 
++      val = (((((val & MASK20) + value) & MASK20) << 2)
+ 	    | (val & ~(MASK20 << 2)));
+       grub_set_unaligned32 (((grub_uint8_t *) (addr & MASK3) + 2),
+ 			    grub_cpu_to_le32 (val));
+@@ -161,9 +161,9 @@ static grub_uint8_t jump[0x20] =
+     /* 	[MIB]       ld8 r1=[r15] */
+     0x11, 0x08, 0x00, 0x1e, 0x18, 0x10,
+     /* mov b6=r16 */
+-    0x60, 0x80, 0x04, 0x80, 0x03, 0x00, 
++    0x60, 0x80, 0x04, 0x80, 0x03, 0x00,
+     /* br.few b6;; */
+-    0x60, 0x00, 0x80, 0x00       	            
++    0x60, 0x00, 0x80, 0x00
+   };
+ #else
+ static const grub_uint8_t jump[0x20] =
+diff --git a/grub-core/kern/ieee1275/ieee1275.c b/grub-core/kern/ieee1275/ieee1275.c
+index 86f81a3..4fe72a5 100644
+--- a/grub-core/kern/ieee1275/ieee1275.c
++++ b/grub-core/kern/ieee1275/ieee1275.c
+@@ -306,7 +306,7 @@ grub_ieee1275_seek (grub_ieee1275_ihandle_t ihandle, grub_disk_addr_t pos,
+   args.pos_lo = pos;
+ #else
+   args.pos_hi = (grub_ieee1275_cell_t) (pos >> (8 * GRUB_IEEE1275_CELL_SIZEOF));
+-  args.pos_lo = (grub_ieee1275_cell_t) 
++  args.pos_lo = (grub_ieee1275_cell_t)
+     (pos & ((1ULL << (8 * GRUB_IEEE1275_CELL_SIZEOF)) - 1));
+ #endif
+ 
+diff --git a/grub-core/kern/ieee1275/init.c b/grub-core/kern/ieee1275/init.c
+index 085a6a3..d1e1862 100644
+--- a/grub-core/kern/ieee1275/init.c
++++ b/grub-core/kern/ieee1275/init.c
+@@ -160,7 +160,7 @@ grub_machine_get_bootlocation (char **device, char **path)
+ 
+ /* Claim some available memory in the first /memory node. */
+ #ifdef __sparc__
+-static void 
++static void
+ grub_claim_heap (void)
+ {
+   grub_mm_init_region ((void *) (grub_modules_get_end ()
+@@ -228,7 +228,7 @@ heap_init (grub_uint64_t addr, grub_uint64_t len, grub_memory_type_t type,
+   return 0;
+ }
+ 
+-static void 
++static void
+ grub_claim_heap (void)
+ {
+   unsigned long total = 0;
+@@ -286,7 +286,7 @@ grub_addr_t grub_modbase;
+ void
+ grub_machine_init (void)
+ {
+-  grub_modbase = ALIGN_UP((grub_addr_t) _end 
++  grub_modbase = ALIGN_UP((grub_addr_t) _end
+ 			  + GRUB_KERNEL_MACHINE_MOD_GAP,
+ 			  GRUB_KERNEL_MACHINE_MOD_ALIGN);
+   grub_ieee1275_init ();
+diff --git a/grub-core/kern/ieee1275/openfw.c b/grub-core/kern/ieee1275/openfw.c
+index 4d493ab..11b2beb 100644
+--- a/grub-core/kern/ieee1275/openfw.c
++++ b/grub-core/kern/ieee1275/openfw.c
+@@ -404,7 +404,7 @@ grub_ieee1275_parse_args (const char *path, enum grub_ieee1275_parse_type ptype)
+ 	if (comma)
+ 	  {
+ 	    char *filepath = comma + 1;
+-	    
++
+ 	    /* Make sure filepath has leading backslash.  */
+ 	    if (filepath[0] != '\\')
+ 	      ret = grub_xasprintf ("\\%s", filepath);
+diff --git a/grub-core/kern/main.c b/grub-core/kern/main.c
+index c6fb668..40ab83d 100644
+--- a/grub-core/kern/main.c
++++ b/grub-core/kern/main.c
+@@ -210,7 +210,7 @@ grub_set_prefix_and_root (void)
+   if (device)
+     {
+       char *prefix_set;
+-    
++
+       prefix_set = grub_xasprintf ("(%s)%s", device, path ? : "");
+       if (prefix_set)
+ 	{
+@@ -300,7 +300,7 @@ grub_main (void)
+   grub_register_exported_symbols ();
+ #ifdef GRUB_LINKER_HAVE_INIT
+   grub_arch_dl_init_linker ();
+-#endif  
++#endif
+   grub_load_modules ();
+ 
+   grub_boot_time ("After loading embedded modules.");
+diff --git a/grub-core/kern/mips/dl.c b/grub-core/kern/mips/dl.c
+index 5d7d299..5b02f97 100644
+--- a/grub-core/kern/mips/dl.c
++++ b/grub-core/kern/mips/dl.c
+@@ -164,7 +164,7 @@ grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+ #endif
+ 
+ 	    /* Handle partner lo16 relocation. Lower part is
+-	       treated as signed. Hence add 0x8000 to compensate. 
++	       treated as signed. Hence add 0x8000 to compensate.
+ 	    */
+ 	    value = (*(grub_uint16_t *) addr << 16)
+ 	      + sym_value + 0x8000;
+@@ -206,8 +206,8 @@ grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+ 	    value = raw << 2;
+ 	    value += sym_value;
+ 	    raw = (value >> 2) & 0x3ffffff;
+-			
+-	    *(grub_uint32_t *) addr = 
++
++	    *(grub_uint32_t *) addr =
+ 	      raw | ((*(grub_uint32_t *) addr) & 0xfc000000);
+ 	  }
+ 	  break;
+@@ -265,7 +265,7 @@ grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+   return GRUB_ERR_NONE;
+ }
+ 
+-void 
++void
+ grub_arch_dl_init_linker (void)
+ {
+   grub_dl_register_symbol ("__gnu_local_gp", &__gnu_local_gp_dummy, 0, 0);
+diff --git a/grub-core/kern/mips/loongson/init.c b/grub-core/kern/mips/loongson/init.c
+index dff598c..97b09b0 100644
+--- a/grub-core/kern/mips/loongson/init.c
++++ b/grub-core/kern/mips/loongson/init.c
+@@ -107,10 +107,10 @@ init_pci (void)
+ 
+   *((volatile grub_uint32_t *) (GRUB_MACHINE_PCI_CONTROLLER_HEADER
+ 				+ GRUB_PCI_REG_CACHELINE)) = 0xff;
+-  *((volatile grub_uint32_t *) (GRUB_MACHINE_PCI_CONTROLLER_HEADER 
++  *((volatile grub_uint32_t *) (GRUB_MACHINE_PCI_CONTROLLER_HEADER
+ 				+ GRUB_PCI_REG_ADDRESS_REG0))
+     = 0x80000000 | GRUB_PCI_ADDR_MEM_TYPE_64 | GRUB_PCI_ADDR_MEM_PREFETCH;
+-  *((volatile grub_uint32_t *) (GRUB_MACHINE_PCI_CONTROLLER_HEADER 
++  *((volatile grub_uint32_t *) (GRUB_MACHINE_PCI_CONTROLLER_HEADER
+ 				+ GRUB_PCI_REG_ADDRESS_REG1)) = 0;
+ 
+   grub_pci_iterate (set_card, NULL);
+@@ -183,7 +183,7 @@ grub_machine_init (void)
+       else
+ 	totalmem = ((spd.ddr2.num_of_ranks
+ 		     & GRUB_SMBUS_SPD_MEMORY_NUM_OF_RANKS_MASK) + 1) << (i + 2);
+-      
++
+       if (totalmem >= 256)
+ 	{
+ 	  grub_arch_memsize = 256;
+diff --git a/grub-core/kern/mips/qemu_mips/init.c b/grub-core/kern/mips/qemu_mips/init.c
+index 8b6c55f..69488a3 100644
+--- a/grub-core/kern/mips/qemu_mips/init.c
++++ b/grub-core/kern/mips/qemu_mips/init.c
+@@ -41,7 +41,7 @@ grub_machine_init (void)
+   if (grub_arch_memsize == 0)
+     {
+       int i;
+-      
++
+       for (i = 27; i >= 0; i--)
+ 	if (probe_mem (grub_arch_memsize | (1 << i)))
+ 	  grub_arch_memsize |= (1 << i);
+@@ -87,7 +87,7 @@ grub_halt (void)
+   while (1);
+ }
+ 
+-grub_err_t 
++grub_err_t
+ grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
+ {
+   hook (0, grub_arch_memsize, GRUB_MEMORY_AVAILABLE, hook_data);
+diff --git a/grub-core/kern/misc.c b/grub-core/kern/misc.c
+index 63b586d..35972de 100644
+--- a/grub-core/kern/misc.c
++++ b/grub-core/kern/misc.c
+@@ -1200,7 +1200,7 @@ static void __attribute__ ((noreturn))
+ grub_abort (void)
+ {
+   grub_printf ("\nAborted.");
+-  
++
+ #ifndef GRUB_UTIL
+   if (grub_term_inputs)
+ #endif
+@@ -1264,7 +1264,7 @@ grub_real_boot_time (const char *file,
+   n->next = 0;
+ 
+   va_start (args, fmt);
+-  n->msg = grub_xvasprintf (fmt, args);    
++  n->msg = grub_xvasprintf (fmt, args);
+   va_end (args);
+ 
+   *boot_time_last = n;
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index c686917..079c28d 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -283,7 +283,7 @@ grub_real_malloc (grub_mm_header_t *first, grub_size_t n, grub_size_t align)
+ 	  else if (extra == 0)
+ 	    {
+ 	      grub_mm_header_t r;
+-	      
++
+ 	      r = cur + extra + n;
+ 	      r->magic = GRUB_MM_FREE_MAGIC;
+ 	      r->size = cur->size - extra - n;
+@@ -707,7 +707,7 @@ grub_debug_memalign (const char *file, int line, grub_size_t align,
+   void *ptr;
+ 
+   if (grub_mm_debug)
+-    grub_printf ("%s:%d: memalign (0x%" PRIxGRUB_SIZE  ", 0x%" PRIxGRUB_SIZE  
++    grub_printf ("%s:%d: memalign (0x%" PRIxGRUB_SIZE  ", 0x%" PRIxGRUB_SIZE
+ 		 ") = ", file, line, align, size);
+   ptr = grub_memalign (align, size);
+   if (grub_mm_debug)
+diff --git a/grub-core/kern/partition.c b/grub-core/kern/partition.c
+index 3068c4d..edad9f9 100644
+--- a/grub-core/kern/partition.c
++++ b/grub-core/kern/partition.c
+@@ -128,7 +128,7 @@ grub_partition_probe (struct grub_disk *disk, const char *str)
+       partname = ptr;
+       while (*ptr && grub_isalpha (*ptr))
+ 	ptr++;
+-      partname_end = ptr; 
++      partname_end = ptr;
+       num = grub_strtoul (ptr, &ptr, 0) - 1;
+ 
+       curpart = 0;
+diff --git a/grub-core/kern/powerpc/dl.c b/grub-core/kern/powerpc/dl.c
+index cdd61b3..7b6418e 100644
+--- a/grub-core/kern/powerpc/dl.c
++++ b/grub-core/kern/powerpc/dl.c
+@@ -47,7 +47,7 @@ struct trampoline
+   grub_uint32_t bctr;
+ };
+ 
+-static const struct trampoline trampoline_template = 
++static const struct trampoline trampoline_template =
+   {
+     0x3d800000,
+     0x618c0000,
+@@ -74,7 +74,7 @@ grub_arch_dl_get_tramp_got_size (const void *ehdr, grub_size_t *tramp,
+     if (s->sh_type == SHT_RELA)
+       {
+ 	const Elf_Rela *rel, *max;
+-	
++
+ 	for (rel = (const Elf_Rela *) ((const char *) e + s->sh_offset),
+ 	       max = rel + s->sh_size / s->sh_entsize;
+ 	     rel < max;
+@@ -82,7 +82,7 @@ grub_arch_dl_get_tramp_got_size (const void *ehdr, grub_size_t *tramp,
+ 	  if (ELF_R_TYPE (rel->r_info) == GRUB_ELF_R_PPC_REL24
+ 	      || ELF_R_TYPE (rel->r_info) == GRUB_ELF_R_PPC_PLTREL24)
+ 	    (*tramp)++;
+-	
++
+       }
+ 
+   *tramp *= sizeof (struct trampoline);
+@@ -138,7 +138,7 @@ grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+ 		tptr->ori |= ((value) & 0xffff);
+ 		mod->trampptr = tptr + 1;
+ 	      }
+-			
++
+ 	    if (delta << 6 >> 6 != delta)
+ 	      return grub_error (GRUB_ERR_BAD_MODULE,
+ 				 "relocation overflow");
diff --git a/debian/patches/2.12-mm/0199-mm-Document-GRUB-internal-memory-management-structur.patch b/debian/patches/2.12-mm/0199-mm-Document-GRUB-internal-memory-management-structur.patch
new file mode 100644
index 0000000..89a2502
--- /dev/null
+++ b/debian/patches/2.12-mm/0199-mm-Document-GRUB-internal-memory-management-structur.patch
@@ -0,0 +1,76 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 25 Nov 2021 02:22:45 +1100
+Subject: mm: Document GRUB internal memory management structures
+
+I spent more than a trivial quantity of time figuring out pre_size and
+whether a memory region's size contains the header cell or not.
+
+Document the meanings of all the properties. Hopefully now no-one else
+has to figure it out!
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ include/grub/mm_private.h | 28 ++++++++++++++++++++++++++++
+ 1 file changed, 28 insertions(+)
+
+diff --git a/include/grub/mm_private.h b/include/grub/mm_private.h
+index c2c4cb1..203533c 100644
+--- a/include/grub/mm_private.h
++++ b/include/grub/mm_private.h
+@@ -21,15 +21,27 @@
+ 
+ #include <grub/mm.h>
+ 
++/* For context, see kern/mm.c */
++
+ /* Magic words.  */
+ #define GRUB_MM_FREE_MAGIC	0x2d3c2808
+ #define GRUB_MM_ALLOC_MAGIC	0x6db08fa4
+ 
++/* A header describing a block of memory - either allocated or free */
+ typedef struct grub_mm_header
+ {
++  /*
++   * The 'next' free block in this region's circular free list.
++   * Only meaningful if the block is free.
++   */
+   struct grub_mm_header *next;
++  /* The block size, not in bytes but the number of cells of
++   * GRUB_MM_ALIGN bytes. Includes the header cell.
++   */
+   grub_size_t size;
++  /* either free or alloc magic, depending on the block type. */
+   grub_size_t magic;
++  /* pad to cell size: see the top of kern/mm.c. */
+ #if GRUB_CPU_SIZEOF_VOID_P == 4
+   char padding[4];
+ #elif GRUB_CPU_SIZEOF_VOID_P == 8
+@@ -48,11 +60,27 @@ typedef struct grub_mm_header
+ 
+ #define GRUB_MM_ALIGN	(1 << GRUB_MM_ALIGN_LOG2)
+ 
++/* A region from which we can make allocations. */
+ typedef struct grub_mm_region
+ {
++  /* The first free block in this region. */
+   struct grub_mm_header *first;
++
++  /*
++   * The next region in the linked list of regions. Regions are initially
++   * sorted in order of increasing size, but can grow, in which case the
++   * ordering may not be preserved.
++   */
+   struct grub_mm_region *next;
++
++  /*
++   * A grub_mm_region will always be aligned to cell size. The pre-size is
++   * the number of bytes we were given but had to skip in order to get that
++   * alignment.
++   */
+   grub_size_t pre_size;
++
++  /* How many bytes are in this region? (free and allocated) */
+   grub_size_t size;
+ }
+ *grub_mm_region_t;
diff --git a/debian/patches/2.12-mm/0200-mm-Assert-that-we-preserve-header-vs-region-alignmen.patch b/debian/patches/2.12-mm/0200-mm-Assert-that-we-preserve-header-vs-region-alignmen.patch
new file mode 100644
index 0000000..0ba40df
--- /dev/null
+++ b/debian/patches/2.12-mm/0200-mm-Assert-that-we-preserve-header-vs-region-alignmen.patch
@@ -0,0 +1,54 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 21 Apr 2022 15:24:14 +1000
+Subject: mm: Assert that we preserve header vs region alignment
+
+grub_mm_region_init() does:
+
+  h = (grub_mm_header_t) (r + 1);
+
+where h is a grub_mm_header_t and r is a grub_mm_region_t.
+
+Cells are supposed to be GRUB_MM_ALIGN aligned, but while grub_mm_dump
+ensures this vs the region header, grub_mm_region_init() does not.
+
+It's better to be explicit than implicit here: rather than changing
+grub_mm_region_init() to ALIGN_UP(), require that the struct is
+explicitly a multiple of the header size.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ include/grub/mm_private.h | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/include/grub/mm_private.h b/include/grub/mm_private.h
+index 203533c..a688b92 100644
+--- a/include/grub/mm_private.h
++++ b/include/grub/mm_private.h
+@@ -20,6 +20,7 @@
+ #define GRUB_MM_PRIVATE_H	1
+ 
+ #include <grub/mm.h>
++#include <grub/misc.h>
+ 
+ /* For context, see kern/mm.c */
+ 
+@@ -89,4 +90,17 @@ typedef struct grub_mm_region
+ extern grub_mm_region_t EXPORT_VAR (grub_mm_base);
+ #endif
+ 
++static inline void
++grub_mm_size_sanity_check (void) {
++  /* Ensure we preserve alignment when doing h = (grub_mm_header_t) (r + 1). */
++  COMPILE_TIME_ASSERT ((sizeof (struct grub_mm_region) %
++		        sizeof (struct grub_mm_header)) == 0);
++
++  /*
++   * GRUB_MM_ALIGN is supposed to represent cell size, and a mm_header is
++   * supposed to be 1 cell.
++   */
++  COMPILE_TIME_ASSERT (sizeof (struct grub_mm_header) == GRUB_MM_ALIGN);
++}
++
+ #endif
diff --git a/debian/patches/2.12-mm/0201-mm-When-adding-a-region-merge-with-region-after-as-w.patch b/debian/patches/2.12-mm/0201-mm-When-adding-a-region-merge-with-region-after-as-w.patch
new file mode 100644
index 0000000..0cba7f9
--- /dev/null
+++ b/debian/patches/2.12-mm/0201-mm-When-adding-a-region-merge-with-region-after-as-w.patch
@@ -0,0 +1,201 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 21 Apr 2022 15:24:15 +1000
+Subject: mm: When adding a region, merge with region after as well as before
+
+On x86_64-efi (at least) regions seem to be added from top down. The mm
+code will merge a new region with an existing region that comes
+immediately before the new region. This allows larger allocations to be
+satisfied that would otherwise be the case.
+
+On powerpc-ieee1275, however, regions are added from bottom up. So if
+we add 3x 32MB regions, we can still only satisfy a 32MB allocation,
+rather than the 96MB allocation we might otherwise be able to satisfy.
+
+  * Define 'post_size' as being bytes lost to the end of an allocation
+    due to being given weird sizes from firmware that are not multiples
+    of GRUB_MM_ALIGN.
+
+  * Allow merging of regions immediately _after_ existing regions, not
+    just before. As with the other approach, we create an allocated
+    block to represent the new space and the pass it to grub_free() to
+    get the metadata right.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Tested-by: Stefan Berger <stefanb@linux.ibm.com>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/mm.c       | 130 +++++++++++++++++++++++++++++-----------------
+ include/grub/mm_private.h |   9 ++++
+ 2 files changed, 92 insertions(+), 47 deletions(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index 079c28d..b406906 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -130,53 +130,88 @@ grub_mm_init_region (void *addr, grub_size_t size)
+ 
+   /* Attempt to merge this region with every existing region */
+   for (p = &grub_mm_base, q = *p; q; p = &(q->next), q = *p)
+-    /*
+-     * Is the new region immediately below an existing region? That
+-     * is, is the address of the memory we're adding now (addr) + size
+-     * of the memory we're adding (size) + the bytes we couldn't use
+-     * at the start of the region we're considering (q->pre_size)
+-     * equal to the address of q? In other words, does the memory
+-     * looks like this?
+-     *
+-     * addr                          q
+-     *   |----size-----|-q->pre_size-|<q region>|
+-     */
+-    if ((grub_uint8_t *) addr + size + q->pre_size == (grub_uint8_t *) q)
+-      {
+-	/*
+-	 * Yes, we can merge the memory starting at addr into the
+-	 * existing region from below. Align up addr to GRUB_MM_ALIGN
+-	 * so that our new region has proper alignment.
+-	 */
+-	r = (grub_mm_region_t) ALIGN_UP ((grub_addr_t) addr, GRUB_MM_ALIGN);
+-	/* Copy the region data across */
+-	*r = *q;
+-	/* Consider all the new size as pre-size */
+-	r->pre_size += size;
+-
+-	/*
+-	 * If we have enough pre-size to create a block, create a
+-	 * block with it. Mark it as allocated and pass it to
+-	 * grub_free (), which will sort out getting it into the free
+-	 * list.
+-	 */
+-	if (r->pre_size >> GRUB_MM_ALIGN_LOG2)
+-	  {
+-	    h = (grub_mm_header_t) (r + 1);
+-	    /* block size is pre-size converted to cells */
+-	    h->size = (r->pre_size >> GRUB_MM_ALIGN_LOG2);
+-	    h->magic = GRUB_MM_ALLOC_MAGIC;
+-	    /* region size grows by block size converted back to bytes */
+-	    r->size += h->size << GRUB_MM_ALIGN_LOG2;
+-	    /* adjust pre_size to be accurate */
+-	    r->pre_size &= (GRUB_MM_ALIGN - 1);
+-	    *p = r;
+-	    grub_free (h + 1);
+-	  }
+-	/* Replace the old region with the new region */
+-	*p = r;
+-	return;
+-      }
++    {
++      /*
++       * Is the new region immediately below an existing region? That
++       * is, is the address of the memory we're adding now (addr) + size
++       * of the memory we're adding (size) + the bytes we couldn't use
++       * at the start of the region we're considering (q->pre_size)
++       * equal to the address of q? In other words, does the memory
++       * looks like this?
++       *
++       * addr                          q
++       *   |----size-----|-q->pre_size-|<q region>|
++       */
++      if ((grub_uint8_t *) addr + size + q->pre_size == (grub_uint8_t *) q)
++        {
++          /*
++           * Yes, we can merge the memory starting at addr into the
++           * existing region from below. Align up addr to GRUB_MM_ALIGN
++           * so that our new region has proper alignment.
++           */
++          r = (grub_mm_region_t) ALIGN_UP ((grub_addr_t) addr, GRUB_MM_ALIGN);
++          /* Copy the region data across */
++          *r = *q;
++          /* Consider all the new size as pre-size */
++          r->pre_size += size;
++
++          /*
++           * If we have enough pre-size to create a block, create a
++           * block with it. Mark it as allocated and pass it to
++           * grub_free (), which will sort out getting it into the free
++           * list.
++           */
++          if (r->pre_size >> GRUB_MM_ALIGN_LOG2)
++            {
++              h = (grub_mm_header_t) (r + 1);
++              /* block size is pre-size converted to cells */
++              h->size = (r->pre_size >> GRUB_MM_ALIGN_LOG2);
++              h->magic = GRUB_MM_ALLOC_MAGIC;
++              /* region size grows by block size converted back to bytes */
++              r->size += h->size << GRUB_MM_ALIGN_LOG2;
++              /* adjust pre_size to be accurate */
++              r->pre_size &= (GRUB_MM_ALIGN - 1);
++              *p = r;
++              grub_free (h + 1);
++            }
++          /* Replace the old region with the new region */
++          *p = r;
++          return;
++        }
++
++      /*
++       * Is the new region immediately above an existing region? That
++       * is:
++       *   q                       addr
++       *   |<q region>|-q->post_size-|----size-----|
++       */
++      if ((grub_uint8_t *) q + sizeof (*q) + q->size + q->post_size ==
++	  (grub_uint8_t *) addr)
++	{
++	  /*
++	   * Yes! Follow a similar pattern to above, but simpler.
++	   * Our header starts at address - post_size, which should align us
++	   * to a cell boundary.
++	   *
++	   * Cast to (void *) first to avoid the following build error:
++	   *   kern/mm.c: In function ‘grub_mm_init_region’:
++	   *   kern/mm.c:211:15: error: cast increases required alignment of target type [-Werror=cast-align]
++	   *     211 |           h = (grub_mm_header_t) ((grub_uint8_t *) addr - q->post_size);
++	   *         |               ^
++	   * It is safe to do that because proper alignment is enforced in grub_mm_size_sanity_check().
++	   */
++	  h = (grub_mm_header_t)(void *) ((grub_uint8_t *) addr - q->post_size);
++	  /* our size is the allocated size plus post_size, in cells */
++	  h->size = (size + q->post_size) >> GRUB_MM_ALIGN_LOG2;
++	  h->magic = GRUB_MM_ALLOC_MAGIC;
++	  /* region size grows by block size converted back to bytes */
++	  q->size += h->size << GRUB_MM_ALIGN_LOG2;
++	  /* adjust new post_size to be accurate */
++	  q->post_size = (q->post_size + size) & (GRUB_MM_ALIGN - 1);
++	  grub_free (h + 1);
++	  return;
++	}
++    }
+ 
+   /* Allocate a region from the head.  */
+   r = (grub_mm_region_t) ALIGN_UP ((grub_addr_t) addr, GRUB_MM_ALIGN);
+@@ -195,6 +230,7 @@ grub_mm_init_region (void *addr, grub_size_t size)
+   r->first = h;
+   r->pre_size = (grub_addr_t) r - (grub_addr_t) addr;
+   r->size = (h->size << GRUB_MM_ALIGN_LOG2);
++  r->post_size = size - r->size;
+ 
+   /* Find where to insert this region. Put a smaller one before bigger ones,
+      to prevent fragmentation.  */
+diff --git a/include/grub/mm_private.h b/include/grub/mm_private.h
+index a688b92..96c2d81 100644
+--- a/include/grub/mm_private.h
++++ b/include/grub/mm_private.h
+@@ -81,8 +81,17 @@ typedef struct grub_mm_region
+    */
+   grub_size_t pre_size;
+ 
++  /*
++   * Likewise, the post-size is the number of bytes we wasted at the end
++   * of the allocation because it wasn't a multiple of GRUB_MM_ALIGN
++   */
++  grub_size_t post_size;
++
+   /* How many bytes are in this region? (free and allocated) */
+   grub_size_t size;
++
++  /* pad to a multiple of cell size */
++  char padding[3 * GRUB_CPU_SIZEOF_VOID_P];
+ }
+ *grub_mm_region_t;
+ 
diff --git a/debian/patches/2.12-mm/0202-mm-Debug-support-for-region-operations.patch b/debian/patches/2.12-mm/0202-mm-Debug-support-for-region-operations.patch
new file mode 100644
index 0000000..839f733
--- /dev/null
+++ b/debian/patches/2.12-mm/0202-mm-Debug-support-for-region-operations.patch
@@ -0,0 +1,69 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Thu, 21 Apr 2022 15:24:16 +1000
+Subject: mm: Debug support for region operations
+
+This is handy for debugging. Enable with "set debug=regions".
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/mm.c | 19 ++++++++++++++++---
+ 1 file changed, 16 insertions(+), 3 deletions(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index b406906..43d4e60 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -115,9 +115,8 @@ grub_mm_init_region (void *addr, grub_size_t size)
+   grub_mm_header_t h;
+   grub_mm_region_t r, *p, q;
+ 
+-#if 0
+-  grub_printf ("Using memory for heap: start=%p, end=%p\n", addr, addr + (unsigned int) size);
+-#endif
++  grub_dprintf ("regions", "Using memory for heap: start=%p, end=%p\n",
++                addr, (char *) addr + (unsigned int) size);
+ 
+   /* Exclude last 4K to avoid overflows. */
+   /* If addr + 0x1000 overflows then whole region is in excluded zone.  */
+@@ -142,8 +141,14 @@ grub_mm_init_region (void *addr, grub_size_t size)
+        * addr                          q
+        *   |----size-----|-q->pre_size-|<q region>|
+        */
++      grub_dprintf ("regions", "Can we extend into region above?"
++		    " %p + %" PRIxGRUB_SIZE " + %" PRIxGRUB_SIZE " ?=? %p\n",
++		    (grub_uint8_t *) addr, size, q->pre_size, (grub_uint8_t *) q);
+       if ((grub_uint8_t *) addr + size + q->pre_size == (grub_uint8_t *) q)
+         {
++	  grub_dprintf ("regions", "Yes: extending a region: (%p -> %p) -> (%p -> %p)\n",
++			q, (grub_uint8_t *) q + sizeof (*q) + q->size,
++			addr, (grub_uint8_t *) q + sizeof (*q) + q->size);
+           /*
+            * Yes, we can merge the memory starting at addr into the
+            * existing region from below. Align up addr to GRUB_MM_ALIGN
+@@ -185,9 +190,15 @@ grub_mm_init_region (void *addr, grub_size_t size)
+        *   q                       addr
+        *   |<q region>|-q->post_size-|----size-----|
+        */
++      grub_dprintf ("regions", "Can we extend into region below?"
++                    " %p + %" PRIxGRUB_SIZE " + %" PRIxGRUB_SIZE " + %" PRIxGRUB_SIZE " ?=? %p\n",
++                    (grub_uint8_t *) q, sizeof(*q), q->size, q->post_size, (grub_uint8_t *) addr);
+       if ((grub_uint8_t *) q + sizeof (*q) + q->size + q->post_size ==
+ 	  (grub_uint8_t *) addr)
+ 	{
++	  grub_dprintf ("regions", "Yes: extending a region: (%p -> %p) -> (%p -> %p)\n",
++			q, (grub_uint8_t *) q + sizeof (*q) + q->size,
++			q, (grub_uint8_t *) addr + size);
+ 	  /*
+ 	   * Yes! Follow a similar pattern to above, but simpler.
+ 	   * Our header starts at address - post_size, which should align us
+@@ -213,6 +224,8 @@ grub_mm_init_region (void *addr, grub_size_t size)
+ 	}
+     }
+ 
++  grub_dprintf ("regions", "No: considering a new region at %p of size %" PRIxGRUB_SIZE "\n",
++		addr, size);
+   /* Allocate a region from the head.  */
+   r = (grub_mm_region_t) ALIGN_UP ((grub_addr_t) addr, GRUB_MM_ALIGN);
+ 
diff --git a/debian/patches/2.12-mm/0203-mm-Drop-unused-unloading-of-modules-on-OOM.patch b/debian/patches/2.12-mm/0203-mm-Drop-unused-unloading-of-modules-on-OOM.patch
new file mode 100644
index 0000000..1d25437
--- /dev/null
+++ b/debian/patches/2.12-mm/0203-mm-Drop-unused-unloading-of-modules-on-OOM.patch
@@ -0,0 +1,78 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:17 +1000
+Subject: mm: Drop unused unloading of modules on OOM
+
+In grub_memalign(), there's a commented section which would allow for
+unloading of unneeded modules in case where there is not enough free
+memory available to satisfy a request. Given that this code is never
+compiled in, let's remove it together with grub_dl_unload_unneeded().
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/dl.c | 20 --------------------
+ grub-core/kern/mm.c |  8 --------
+ include/grub/dl.h   |  1 -
+ 3 files changed, 29 deletions(-)
+
+diff --git a/grub-core/kern/dl.c b/grub-core/kern/dl.c
+index b3e93c3..eecab8f 100644
+--- a/grub-core/kern/dl.c
++++ b/grub-core/kern/dl.c
+@@ -817,23 +817,3 @@ grub_dl_unload (grub_dl_t mod)
+   grub_free (mod);
+   return 1;
+ }
+-
+-/* Unload unneeded modules.  */
+-void
+-grub_dl_unload_unneeded (void)
+-{
+-  /* Because grub_dl_remove modifies the list of modules, this
+-     implementation is tricky.  */
+-  grub_dl_t p = grub_dl_head;
+-
+-  while (p)
+-    {
+-      if (grub_dl_unload (p))
+-	{
+-	  p = grub_dl_head;
+-	  continue;
+-	}
+-
+-      p = p->next;
+-    }
+-}
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index 43d4e60..e859772 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -444,14 +444,6 @@ grub_memalign (grub_size_t align, grub_size_t size)
+       count++;
+       goto again;
+ 
+-#if 0
+-    case 1:
+-      /* Unload unneeded modules.  */
+-      grub_dl_unload_unneeded ();
+-      count++;
+-      goto again;
+-#endif
+-
+     default:
+       break;
+     }
+diff --git a/include/grub/dl.h b/include/grub/dl.h
+index b3753c9..5367177 100644
+--- a/include/grub/dl.h
++++ b/include/grub/dl.h
+@@ -203,7 +203,6 @@ grub_dl_t EXPORT_FUNC(grub_dl_load) (const char *name);
+ grub_dl_t grub_dl_load_core (void *addr, grub_size_t size);
+ grub_dl_t EXPORT_FUNC(grub_dl_load_core_noinit) (void *addr, grub_size_t size);
+ int EXPORT_FUNC(grub_dl_unload) (grub_dl_t mod);
+-extern void grub_dl_unload_unneeded (void);
+ extern int EXPORT_FUNC(grub_dl_ref) (grub_dl_t mod);
+ extern int EXPORT_FUNC(grub_dl_unref) (grub_dl_t mod);
+ extern int EXPORT_FUNC(grub_dl_ref_count) (grub_dl_t mod);
diff --git a/debian/patches/2.12-mm/0204-mm-Allow-dynamically-requesting-additional-memory-re.patch b/debian/patches/2.12-mm/0204-mm-Allow-dynamically-requesting-additional-memory-re.patch
new file mode 100644
index 0000000..9f4cbe0
--- /dev/null
+++ b/debian/patches/2.12-mm/0204-mm-Allow-dynamically-requesting-additional-memory-re.patch
@@ -0,0 +1,128 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:18 +1000
+Subject: mm: Allow dynamically requesting additional memory regions
+
+Currently, all platforms will set up their heap on initialization of the
+platform code. While this works mostly fine, it poses some limitations
+on memory management on us. Most notably, allocating big chunks of
+memory in the gigabyte range would require us to pre-request this many
+bytes from the firmware and add it to the heap from the beginning on
+some platforms like EFI. As this isn't needed for most configurations,
+it is inefficient and may even negatively impact some usecases when,
+e.g., chainloading. Nonetheless, allocating big chunks of memory is
+required sometimes, where one example is the upcoming support for the
+Argon2 key derival function in LUKS2.
+
+In order to avoid pre-allocating big chunks of memory, this commit
+implements a runtime mechanism to add more pages to the system. When
+a given allocation cannot be currently satisfied, we'll call a given
+callback set up by the platform's own memory management subsystem,
+asking it to add a memory area with at least "n" bytes. If this
+succeeds, we retry searching for a valid memory region, which should
+now succeed.
+
+If this fails, we try asking for "n" bytes, possibly spread across
+multiple regions, in hopes that region merging means that we end up
+with enough memory for things to work out.
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Tested-by: Stefan Berger <stefanb@linux.ibm.com>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/mm.c | 30 ++++++++++++++++++++++++++++++
+ include/grub/mm.h   | 18 ++++++++++++++++++
+ 2 files changed, 48 insertions(+)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index e859772..75f6eac 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -28,6 +28,9 @@
+   - multiple regions may be used as free space. They may not be
+   contiguous.
+ 
++  - if existing regions are insufficient to satisfy an allocation, a new
++  region can be requested from firmware.
++
+   Regions are managed by a singly linked list, and the meta information is
+   stored in the beginning of each region. Space after the meta information
+   is used to allocate memory.
+@@ -81,6 +84,7 @@
+ 
+ 
+ grub_mm_region_t grub_mm_base;
++grub_mm_add_region_func_t grub_mm_add_region_fn;
+ 
+ /* Get a header from the pointer PTR, and set *P and *R to a pointer
+    to the header and a pointer to its region, respectively. PTR must
+@@ -444,6 +448,32 @@ grub_memalign (grub_size_t align, grub_size_t size)
+       count++;
+       goto again;
+ 
++    case 1:
++      /* Request additional pages, contiguous */
++      count++;
++
++      if (grub_mm_add_region_fn != NULL &&
++          grub_mm_add_region_fn (size, GRUB_MM_ADD_REGION_CONSECUTIVE) == GRUB_ERR_NONE)
++	goto again;
++
++      /* fallthrough  */
++
++    case 2:
++      /* Request additional pages, anything at all */
++      count++;
++
++      if (grub_mm_add_region_fn != NULL)
++        {
++          /*
++           * Try again even if this fails, in case it was able to partially
++           * satisfy the request
++           */
++          grub_mm_add_region_fn (size, GRUB_MM_ADD_REGION_NONE);
++          goto again;
++        }
++
++      /* fallthrough */
++
+     default:
+       break;
+     }
+diff --git a/include/grub/mm.h b/include/grub/mm.h
+index 9c38dd3..d2d6fce 100644
+--- a/include/grub/mm.h
++++ b/include/grub/mm.h
+@@ -20,6 +20,7 @@
+ #ifndef GRUB_MM_H
+ #define GRUB_MM_H	1
+ 
++#include <grub/err.h>
+ #include <grub/types.h>
+ #include <grub/symbol.h>
+ #include <config.h>
+@@ -28,6 +29,23 @@
+ # define NULL	((void *) 0)
+ #endif
+ 
++#define GRUB_MM_ADD_REGION_NONE        0
++#define GRUB_MM_ADD_REGION_CONSECUTIVE (1 << 0)
++
++/*
++ * Function used to request memory regions of `grub_size_t` bytes. The second
++ * parameter is a bitfield of `GRUB_MM_ADD_REGION` flags.
++ */
++typedef grub_err_t (*grub_mm_add_region_func_t) (grub_size_t, unsigned int);
++
++/*
++ * Set this function pointer to enable adding memory-regions at runtime in case
++ * a memory allocation cannot be satisfied with existing regions.
++ */
++#ifndef GRUB_MACHINE_EMU
++extern grub_mm_add_region_func_t EXPORT_VAR(grub_mm_add_region_fn);
++#endif
++
+ void grub_mm_init_region (void *addr, grub_size_t size);
+ void *EXPORT_FUNC(grub_calloc) (grub_size_t nmemb, grub_size_t size);
+ void *EXPORT_FUNC(grub_malloc) (grub_size_t size);
diff --git a/debian/patches/2.12-mm/0205-kern-efi-mm-Always-request-a-fixed-number-of-pages-o.patch b/debian/patches/2.12-mm/0205-kern-efi-mm-Always-request-a-fixed-number-of-pages-o.patch
new file mode 100644
index 0000000..20aaaf0
--- /dev/null
+++ b/debian/patches/2.12-mm/0205-kern-efi-mm-Always-request-a-fixed-number-of-pages-o.patch
@@ -0,0 +1,101 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:19 +1000
+Subject: kern/efi/mm: Always request a fixed number of pages on init
+
+When initializing the EFI memory subsystem, we will by default request
+a quarter of the available memory, bounded by a minimum/maximum value.
+Given that we're about to extend the EFI memory system to dynamically
+request additional pages from the firmware as required, this scaling of
+requested memory based on available memory will not make a lot of sense
+anymore.
+
+Remove this logic as a preparatory patch such that we'll instead defer
+to the runtime memory allocator. Note that ideally, we'd want to change
+this after dynamic requesting of pages has been implemented for the EFI
+platform. But because we'll need to split up initialization of the
+memory subsystem and the request of pages from the firmware, we'd have
+to duplicate quite some logic at first only to remove it afterwards
+again. This seems quite pointless, so we instead have patches slightly
+out of order.
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/efi/mm.c | 35 +++--------------------------------
+ 1 file changed, 3 insertions(+), 32 deletions(-)
+
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index dac9c58..e4f90ad 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -38,9 +38,8 @@
+    a multiplier of 4KB.  */
+ #define MEMORY_MAP_SIZE	0x3000
+ 
+-/* The minimum and maximum heap size for GRUB itself.  */
+-#define MIN_HEAP_SIZE	0x100000
+-#define MAX_HEAP_SIZE	(1600 * 0x100000)
++/* The default heap size for GRUB itself in bytes.  */
++#define DEFAULT_HEAP_SIZE	0x100000
+ 
+ static void *finish_mmap_buf = 0;
+ static grub_efi_uintn_t finish_mmap_size = 0;
+@@ -510,23 +509,6 @@ filter_memory_map (grub_efi_memory_descriptor_t *memory_map,
+   return filtered_desc;
+ }
+ 
+-/* Return the total number of pages.  */
+-static grub_efi_uint64_t
+-get_total_pages (grub_efi_memory_descriptor_t *memory_map,
+-		 grub_efi_uintn_t desc_size,
+-		 grub_efi_memory_descriptor_t *memory_map_end)
+-{
+-  grub_efi_memory_descriptor_t *desc;
+-  grub_efi_uint64_t total = 0;
+-
+-  for (desc = memory_map;
+-       desc < memory_map_end;
+-       desc = NEXT_MEMORY_DESCRIPTOR (desc, desc_size))
+-    total += desc->num_pages;
+-
+-  return total;
+-}
+-
+ /* Add memory regions.  */
+ static void
+ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+@@ -615,8 +597,6 @@ grub_efi_mm_init (void)
+   grub_efi_memory_descriptor_t *filtered_memory_map_end;
+   grub_efi_uintn_t map_size;
+   grub_efi_uintn_t desc_size;
+-  grub_efi_uint64_t total_pages;
+-  grub_efi_uint64_t required_pages;
+   int mm_status;
+ 
+   /* Prepare a memory region to store two memory maps.  */
+@@ -656,22 +636,13 @@ grub_efi_mm_init (void)
+   filtered_memory_map_end = filter_memory_map (memory_map, filtered_memory_map,
+ 					       desc_size, memory_map_end);
+ 
+-  /* By default, request a quarter of the available memory.  */
+-  total_pages = get_total_pages (filtered_memory_map, desc_size,
+-				 filtered_memory_map_end);
+-  required_pages = (total_pages >> 2);
+-  if (required_pages < BYTES_TO_PAGES (MIN_HEAP_SIZE))
+-    required_pages = BYTES_TO_PAGES (MIN_HEAP_SIZE);
+-  else if (required_pages > BYTES_TO_PAGES (MAX_HEAP_SIZE))
+-    required_pages = BYTES_TO_PAGES (MAX_HEAP_SIZE);
+-
+   /* Sort the filtered descriptors, so that GRUB can allocate pages
+      from smaller regions.  */
+   sort_memory_map (filtered_memory_map, desc_size, filtered_memory_map_end);
+ 
+   /* Allocate memory regions for GRUB's memory management.  */
+   add_memory_regions (filtered_memory_map, desc_size,
+-		      filtered_memory_map_end, required_pages);
++		      filtered_memory_map_end, BYTES_TO_PAGES (DEFAULT_HEAP_SIZE));
+ 
+ #if 0
+   /* For debug.  */
diff --git a/debian/patches/2.12-mm/0206-kern-efi-mm-Extract-function-to-add-memory-regions.patch b/debian/patches/2.12-mm/0206-kern-efi-mm-Extract-function-to-add-memory-regions.patch
new file mode 100644
index 0000000..9f80c19
--- /dev/null
+++ b/debian/patches/2.12-mm/0206-kern-efi-mm-Extract-function-to-add-memory-regions.patch
@@ -0,0 +1,82 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:20 +1000
+Subject: kern/efi/mm: Extract function to add memory regions
+
+In preparation of support for runtime-allocating additional memory
+region, this patch extracts the function to retrieve the EFI memory
+map and add a subset of it to GRUB's own memory regions.
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/efi/mm.c | 21 +++++++++++++++------
+ 1 file changed, 15 insertions(+), 6 deletions(-)
+
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index e4f90ad..b1e1b75 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -588,8 +588,8 @@ print_memory_map (grub_efi_memory_descriptor_t *memory_map,
+ }
+ #endif
+ 
+-void
+-grub_efi_mm_init (void)
++static grub_err_t
++grub_efi_mm_add_regions (grub_size_t required_bytes)
+ {
+   grub_efi_memory_descriptor_t *memory_map;
+   grub_efi_memory_descriptor_t *memory_map_end;
+@@ -602,7 +602,7 @@ grub_efi_mm_init (void)
+   /* Prepare a memory region to store two memory maps.  */
+   memory_map = grub_efi_allocate_any_pages (2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
+   if (! memory_map)
+-    grub_fatal ("cannot allocate memory");
++    return grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate memory for memory map");
+ 
+   /* Obtain descriptors for available memory.  */
+   map_size = MEMORY_MAP_SIZE;
+@@ -620,14 +620,14 @@ grub_efi_mm_init (void)
+ 
+       memory_map = grub_efi_allocate_any_pages (2 * BYTES_TO_PAGES (map_size));
+       if (! memory_map)
+-	grub_fatal ("cannot allocate memory");
++	return grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate memory for new memory map");
+ 
+       mm_status = grub_efi_get_memory_map (&map_size, memory_map, 0,
+ 					   &desc_size, 0);
+     }
+ 
+   if (mm_status < 0)
+-    grub_fatal ("cannot get memory map");
++    return grub_error (GRUB_ERR_OUT_OF_MEMORY, "error fetching memory map from EFI");
+ 
+   memory_map_end = NEXT_MEMORY_DESCRIPTOR (memory_map, map_size);
+ 
+@@ -642,7 +642,7 @@ grub_efi_mm_init (void)
+ 
+   /* Allocate memory regions for GRUB's memory management.  */
+   add_memory_regions (filtered_memory_map, desc_size,
+-		      filtered_memory_map_end, BYTES_TO_PAGES (DEFAULT_HEAP_SIZE));
++		      filtered_memory_map_end, BYTES_TO_PAGES (required_bytes));
+ 
+ #if 0
+   /* For debug.  */
+@@ -660,6 +660,15 @@ grub_efi_mm_init (void)
+   /* Release the memory maps.  */
+   grub_efi_free_pages ((grub_addr_t) memory_map,
+ 		       2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
++
++  return GRUB_ERR_NONE;
++}
++
++void
++grub_efi_mm_init (void)
++{
++  if (grub_efi_mm_add_regions (DEFAULT_HEAP_SIZE) != GRUB_ERR_NONE)
++    grub_fatal ("%s", grub_errmsg);
+ }
+ 
+ #if defined (__aarch64__) || defined (__arm__) || defined (__riscv)
diff --git a/debian/patches/2.12-mm/0207-kern-efi-mm-Pass-up-errors-from-add_memory_regions.patch b/debian/patches/2.12-mm/0207-kern-efi-mm-Pass-up-errors-from-add_memory_regions.patch
new file mode 100644
index 0000000..01439ed
--- /dev/null
+++ b/debian/patches/2.12-mm/0207-kern-efi-mm-Pass-up-errors-from-add_memory_regions.patch
@@ -0,0 +1,85 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:21 +1000
+Subject: kern/efi/mm: Pass up errors from add_memory_regions()
+
+The function add_memory_regions() is currently only called on system
+initialization to allocate a fixed amount of pages. As such, it didn't
+need to return any errors: in case it failed, we cannot proceed anyway.
+This will change with the upcoming support for requesting more memory
+from the firmware at runtime, where it doesn't make sense anymore to
+fail hard.
+
+Refactor the function to return an error to prepare for this. Note that
+this does not change the behaviour when initializing the memory system
+because grub_efi_mm_init() knows to call grub_fatal() in case
+grub_efi_mm_add_regions() returns an error.
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/efi/mm.c | 22 +++++++++++++++-------
+ 1 file changed, 15 insertions(+), 7 deletions(-)
+
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index b1e1b75..ac232f5 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -510,7 +510,7 @@ filter_memory_map (grub_efi_memory_descriptor_t *memory_map,
+ }
+ 
+ /* Add memory regions.  */
+-static void
++static grub_err_t
+ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+ 		    grub_efi_uintn_t desc_size,
+ 		    grub_efi_memory_descriptor_t *memory_map_end,
+@@ -538,9 +538,9 @@ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+ 					   GRUB_EFI_ALLOCATE_ADDRESS,
+ 					   GRUB_EFI_LOADER_CODE);
+       if (! addr)
+-	grub_fatal ("cannot allocate conventional memory %p with %u pages",
+-		    (void *) ((grub_addr_t) start),
+-		    (unsigned) pages);
++	return grub_error (GRUB_ERR_OUT_OF_MEMORY,
++			    "Memory starting at %p (%u pages) marked as free, but EFI would not allocate",
++			    (void *) ((grub_addr_t) start), (unsigned) pages);
+ 
+       grub_mm_init_region (addr, PAGES_TO_BYTES (pages));
+ 
+@@ -550,7 +550,11 @@ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+     }
+ 
+   if (required_pages > 0)
+-    grub_fatal ("too little memory");
++    return grub_error (GRUB_ERR_OUT_OF_MEMORY,
++                       "could not allocate all requested memory: %" PRIuGRUB_UINT64_T " pages still required after iterating EFI memory map",
++                       required_pages);
++
++  return GRUB_ERR_NONE;
+ }
+ 
+ void
+@@ -597,6 +601,7 @@ grub_efi_mm_add_regions (grub_size_t required_bytes)
+   grub_efi_memory_descriptor_t *filtered_memory_map_end;
+   grub_efi_uintn_t map_size;
+   grub_efi_uintn_t desc_size;
++  grub_err_t err;
+   int mm_status;
+ 
+   /* Prepare a memory region to store two memory maps.  */
+@@ -641,8 +646,11 @@ grub_efi_mm_add_regions (grub_size_t required_bytes)
+   sort_memory_map (filtered_memory_map, desc_size, filtered_memory_map_end);
+ 
+   /* Allocate memory regions for GRUB's memory management.  */
+-  add_memory_regions (filtered_memory_map, desc_size,
+-		      filtered_memory_map_end, BYTES_TO_PAGES (required_bytes));
++  err = add_memory_regions (filtered_memory_map, desc_size,
++			    filtered_memory_map_end,
++			    BYTES_TO_PAGES (required_bytes));
++  if (err != GRUB_ERR_NONE)
++    return err;
+ 
+ #if 0
+   /* For debug.  */
diff --git a/debian/patches/2.12-mm/0208-kern-efi-mm-Implement-runtime-addition-of-pages.patch b/debian/patches/2.12-mm/0208-kern-efi-mm-Implement-runtime-addition-of-pages.patch
new file mode 100644
index 0000000..11f2dd4
--- /dev/null
+++ b/debian/patches/2.12-mm/0208-kern-efi-mm-Implement-runtime-addition-of-pages.patch
@@ -0,0 +1,73 @@
+From: Patrick Steinhardt <ps@pks.im>
+Date: Thu, 21 Apr 2022 15:24:22 +1000
+Subject: kern/efi/mm: Implement runtime addition of pages
+
+Adjust the interface of grub_efi_mm_add_regions() to take a set of
+GRUB_MM_ADD_REGION_* flags, which most notably is currently only the
+GRUB_MM_ADD_REGION_CONSECUTIVE flag. This allows us to set the function
+up as callback for the memory subsystem and have it call out to us in
+case there's not enough pages available in the current heap.
+
+Signed-off-by: Patrick Steinhardt <ps@pks.im>
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Tested-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/efi/mm.c | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index ac232f5..290d832 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -514,7 +514,8 @@ static grub_err_t
+ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+ 		    grub_efi_uintn_t desc_size,
+ 		    grub_efi_memory_descriptor_t *memory_map_end,
+-		    grub_efi_uint64_t required_pages)
++		    grub_efi_uint64_t required_pages,
++		    unsigned int flags)
+ {
+   grub_efi_memory_descriptor_t *desc;
+ 
+@@ -528,6 +529,10 @@ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
+ 
+       start = desc->physical_start;
+       pages = desc->num_pages;
++
++      if (pages < required_pages && (flags & GRUB_MM_ADD_REGION_CONSECUTIVE))
++	continue;
++
+       if (pages > required_pages)
+ 	{
+ 	  start += PAGES_TO_BYTES (pages - required_pages);
+@@ -593,7 +598,7 @@ print_memory_map (grub_efi_memory_descriptor_t *memory_map,
+ #endif
+ 
+ static grub_err_t
+-grub_efi_mm_add_regions (grub_size_t required_bytes)
++grub_efi_mm_add_regions (grub_size_t required_bytes, unsigned int flags)
+ {
+   grub_efi_memory_descriptor_t *memory_map;
+   grub_efi_memory_descriptor_t *memory_map_end;
+@@ -648,7 +653,8 @@ grub_efi_mm_add_regions (grub_size_t required_bytes)
+   /* Allocate memory regions for GRUB's memory management.  */
+   err = add_memory_regions (filtered_memory_map, desc_size,
+ 			    filtered_memory_map_end,
+-			    BYTES_TO_PAGES (required_bytes));
++			    BYTES_TO_PAGES (required_bytes),
++			    flags);
+   if (err != GRUB_ERR_NONE)
+     return err;
+ 
+@@ -675,8 +681,9 @@ grub_efi_mm_add_regions (grub_size_t required_bytes)
+ void
+ grub_efi_mm_init (void)
+ {
+-  if (grub_efi_mm_add_regions (DEFAULT_HEAP_SIZE) != GRUB_ERR_NONE)
++  if (grub_efi_mm_add_regions (DEFAULT_HEAP_SIZE, GRUB_MM_ADD_REGION_NONE) != GRUB_ERR_NONE)
+     grub_fatal ("%s", grub_errmsg);
++  grub_mm_add_region_fn = grub_efi_mm_add_regions;
+ }
+ 
+ #if defined (__aarch64__) || defined (__arm__) || defined (__riscv)
diff --git a/debian/patches/2.12-mm/0209-efi-Increase-default-memory-allocation-to-32-MiB.patch b/debian/patches/2.12-mm/0209-efi-Increase-default-memory-allocation-to-32-MiB.patch
new file mode 100644
index 0000000..6dedfeb
--- /dev/null
+++ b/debian/patches/2.12-mm/0209-efi-Increase-default-memory-allocation-to-32-MiB.patch
@@ -0,0 +1,29 @@
+From: Daniel Axtens <dja@axtens.net>
+Date: Tue, 20 Sep 2022 00:30:30 +1000
+Subject: efi: Increase default memory allocation to 32 MiB
+
+We have multiple reports of things being slower with a 1 MiB initial static
+allocation, and a report (more difficult to nail down) of a boot failure
+as a result of the smaller initial allocation.
+
+Make the initial memory allocation 32 MiB.
+
+Signed-off-by: Daniel Axtens <dja@axtens.net>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+---
+ grub-core/kern/efi/mm.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
+index 290d832..eb3b33d 100644
+--- a/grub-core/kern/efi/mm.c
++++ b/grub-core/kern/efi/mm.c
+@@ -39,7 +39,7 @@
+ #define MEMORY_MAP_SIZE	0x3000
+ 
+ /* The default heap size for GRUB itself in bytes.  */
+-#define DEFAULT_HEAP_SIZE	0x100000
++#define DEFAULT_HEAP_SIZE	0x2000000
+ 
+ static void *finish_mmap_buf = 0;
+ static grub_efi_uintn_t finish_mmap_size = 0;
diff --git a/debian/patches/2.12-mm/0210-mm-Try-invalidate-disk-caches-last-when-out-of-memor.patch b/debian/patches/2.12-mm/0210-mm-Try-invalidate-disk-caches-last-when-out-of-memor.patch
new file mode 100644
index 0000000..8821e2e
--- /dev/null
+++ b/debian/patches/2.12-mm/0210-mm-Try-invalidate-disk-caches-last-when-out-of-memor.patch
@@ -0,0 +1,55 @@
+From: Zhang Boyang <zhangboyang.id@gmail.com>
+Date: Sat, 15 Oct 2022 22:15:11 +0800
+Subject: mm: Try invalidate disk caches last when out of memory
+
+Every heap grow will cause all disk caches invalidated which decreases
+performance severely. This patch moves disk cache invalidation code to
+the last of memory squeezing measures. So, disk caches are released only
+when there are no other ways to get free memory.
+
+Signed-off-by: Zhang Boyang <zhangboyang.id@gmail.com>
+Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
+Reviewed-by: Patrick Steinhardt <ps@pks.im>
+---
+ grub-core/kern/mm.c | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+diff --git a/grub-core/kern/mm.c b/grub-core/kern/mm.c
+index 75f6eac..ae22791 100644
+--- a/grub-core/kern/mm.c
++++ b/grub-core/kern/mm.c
+@@ -443,12 +443,6 @@ grub_memalign (grub_size_t align, grub_size_t size)
+   switch (count)
+     {
+     case 0:
+-      /* Invalidate disk caches.  */
+-      grub_disk_cache_invalidate_all ();
+-      count++;
+-      goto again;
+-
+-    case 1:
+       /* Request additional pages, contiguous */
+       count++;
+ 
+@@ -458,7 +452,7 @@ grub_memalign (grub_size_t align, grub_size_t size)
+ 
+       /* fallthrough  */
+ 
+-    case 2:
++    case 1:
+       /* Request additional pages, anything at all */
+       count++;
+ 
+@@ -474,6 +468,12 @@ grub_memalign (grub_size_t align, grub_size_t size)
+ 
+       /* fallthrough */
+ 
++    case 2:
++      /* Invalidate disk caches.  */
++      grub_disk_cache_invalidate_all ();
++      count++;
++      goto again;
++
+     default:
+       break;
+     }
diff --git a/debian/patches/series b/debian/patches/series
index 91c78ef..ea78113 100644
--- a/debian/patches/series
+++ b/debian/patches/series
@@ -191,3 +191,20 @@ rhboot-efi-allocate-in-kernel-bounds.patch
 rhboot-efi-allocate-kernel-as-code-for-real.patch
 rhboot-efi-fix-incorrect-array-size.patch
 ubuntu-rhboot-cast-fixups.patch
+2.12-mm/0194-mm-Clarify-grub_real_malloc.patch
+2.12-mm/0195-mm-grub_real_malloc-Make-small-allocs-comment-match-.patch
+2.12-mm/0196-mm-Document-grub_free.patch
+2.12-mm/0197-mm-Document-grub_mm_init_region.patch
+2.12-mm/0198-kern-Remove-trailing-whitespaces.patch
+2.12-mm/0199-mm-Document-GRUB-internal-memory-management-structur.patch
+2.12-mm/0200-mm-Assert-that-we-preserve-header-vs-region-alignmen.patch
+2.12-mm/0201-mm-When-adding-a-region-merge-with-region-after-as-w.patch
+2.12-mm/0202-mm-Debug-support-for-region-operations.patch
+2.12-mm/0203-mm-Drop-unused-unloading-of-modules-on-OOM.patch
+2.12-mm/0204-mm-Allow-dynamically-requesting-additional-memory-re.patch
+2.12-mm/0205-kern-efi-mm-Always-request-a-fixed-number-of-pages-o.patch
+2.12-mm/0206-kern-efi-mm-Extract-function-to-add-memory-regions.patch
+2.12-mm/0207-kern-efi-mm-Pass-up-errors-from-add_memory_regions.patch
+2.12-mm/0208-kern-efi-mm-Implement-runtime-addition-of-pages.patch
+2.12-mm/0209-efi-Increase-default-memory-allocation-to-32-MiB.patch
+2.12-mm/0210-mm-Try-invalidate-disk-caches-last-when-out-of-memor.patch
-- 
cgit v1.1

