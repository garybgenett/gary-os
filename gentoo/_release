#!/usr/bin/env bash
#>>> source ${HOME}/.bashrc
################################################################################

#NOTE: SCRIPT NAME AND FUNCTION NAMES (${PREPIT}, ${MAKEIT}, ${SHIPIT}) MUST MATCH FOR "_SYSTEM" WRAPPING TO WORK
#NOTE: UPDATE "#SETTINGS" LINES IN "_SYSTEM" SCRIPT WHEN THESE VARIABLES CHANGE

export _TITLE="gary-os"
export _VERSN="v4.0"
export _RDATE="$(date --iso=date)"

export _FINAL="${TARGET}/.${_TITLE}-${ESUB}"
export _RAMFS="${_FINAL}/${_TITLE}-${_VERSN}-${ESUB}"

export _GOVLY="/.overlay"
export _GUNPK="/.unpack"
export _GINST="/.install"

export _GREAD="readme.md"
export _GPACK="packages.txt"

########################################

#>>> if [[ -z ${TARGET} ]]; then
#>>> 	_TITLE="${_TITLE}-custom"
#>>> fi

########################################

declare _AUTHOR="Gary B. Genett <me@garybgenett.net>"
declare _LOGIN="garybgenett"

declare _GITHUB="ssh://git@github.com/${_LOGIN}/${_TITLE}.git"
declare _SFCODE="ssh://${_LOGIN}@git.code.sf.net/p/${_TITLE}/code"
declare _SFFILE="${_LOGIN}@web.sourceforge.net:/home/frs/project/${_TITLE}"
declare _SFRSSH="${_LOGIN},${_TITLE}@shell.sourceforge.net create"
declare _SFDOWN="https://sourceforge.net/projects/gary-os/files/${_VERSN}"

declare _DOCDIR="/.g/_data/zactive/coding/${_TITLE}"
declare _BLDDIR="/.g/_data/_builds"
declare _SAVDIR="${_BLDDIR}/_${_TITLE}"
declare _ROOTFS="${_BLDDIR}/_${_TITLE}.rootfs"
declare _RELDIR="${_BLDDIR}/.${_TITLE}"
declare _G_REPO="${_RELDIR}/.${_TITLE}"
declare _OUTDIR="${_RELDIR}.release"

declare _EAMARK="${_FINAL}/_EARLY_ACCESS_DIRECTORY--IN_DEVELOPMENT--UNSUPPORTED"

declare -a RELEASE=
declare -a CMTHASH=
RELEASE[0]="v0.1"; CMTHASH[0]="4d1b46b02798a1d3d3421b1c8087d80a80012a53"
RELEASE[1]="v0.2"; CMTHASH[1]="99c1bafbf1116c1400705803da45e1ac03f3d492"
RELEASE[2]="v0.3"; CMTHASH[2]="6e968d212ea62a1054e3cafa2436b6a98cf8776b"
RELEASE[3]="v1.0"; CMTHASH[3]="f6885f3482b95fe15a688135c441f8f6391c9529"
RELEASE[4]="v1.1"; CMTHASH[4]="9b653e64164e68873333043b41f8bbf23b0fbd55"
RELEASE[5]="v2.0"; CMTHASH[5]="deda452a0aab311f243311b48a39b7ac60ab3fd8"
RELEASE[6]="v3.0"; CMTHASH[6]="35141e1e20259d7d1c2f4b143c6ae4505d7d5045"

########################################

declare CMTFIL="_commit"
declare COMMIT=
for FILE in \
	${_TITLE} \
	.setup \
	.static \
; do
	NEXT="$(cat /.g/_data/zactive{,/coding}/${FILE}.git/refs/heads/master 2>/dev/null)"
	if [[ -n "${NEXT}" ]]; then
		COMMIT="${COMMIT}${FILE}: ${NEXT}\n"
	fi
done

################################################################################

declare LASTPIPE="$(shopt lastpipe | ${SED} "s%^.+(on|off)$%\1%g")"
if [[ ${LASTPIPE} == on ]]; then
	LASTPIPE="-s"
else
	LASTPIPE="-u"
fi

########################################

function variable_parse {
	declare VARIABLE="${1}"		&& shift
	declare V_SPACER="${1:- }"	&& shift
	declare V_PREFIX="${1}"		&& shift
	declare V_SUFFIX="${1}"		&& shift
	declare V_CATGRY="${1:-false}"	&& shift
	declare V_SELECT=
	declare V_LOOPER=
	for V_SELECT in ${VARIABLE}; do
		echo "${!V_SELECT}" | ${SED} "s|${V_SPACER}|\n|g" | while read -r V_LOOPER; do
			if [[ -n ${V_LOOPER} ]]; then
				if ! ${V_CATGRY}; then
					V_LOOPER="$(echo "${V_LOOPER}" | ${SED} "s|^[^${PACKDIRS_CSEP}]+[${PACKDIRS_CSEP}]||g")"
				fi
				echo "${V_PREFIX}${V_LOOPER}${V_SUFFIX}"
			fi
		done
	done
	return 0
}

########################################

function variable_match {
	declare MARIABLE="${1}"		&& shift
	declare M_SPACER="${1:- }"	&& shift
	declare M_EQUALS="${1}"		&& shift
	declare M_SUBDIR="${1:-false}"	&& shift
	declare M_SELECT=
	declare M_LOOPER=
	shopt -s lastpipe
	for M_SELECT in ${MARIABLE}; do
		variable_parse ${M_SELECT} "${M_SPACER}" | while read -r M_LOOPER; do
			if {
				{ ! ${M_SUBDIR} && [[ "${M_EQUALS}" == "${M_LOOPER}" ]]			; } ||
				{ ${M_SUBDIR} && [[ ${M_EQUALS} != ${M_EQUALS/#${M_LOOPER}\/} ]]	; };
			}; then
				shopt ${LASTPIPE} lastpipe
				return 0
			fi
		done
	done
	shopt ${LASTPIPE} lastpipe
	return 1
}

################################################################################

declare RUFUS_URL="https://github.com/pbatard/rufus/releases/download/v3.7/rufus-3.7p.exe"

########################################

#>>> declare SHMEM_MEM="768"
declare SHMEM_MEM="512"

########################################

declare DU_L="${DU} --summarize --total --block-size 1M"
declare DU_S="${DU} --summarize --apparent-size --block-size 1"

########################################

declare CPIO_FILE="${_RAMFS}.cpio"

#note: this is an environment variable for "xz" and is not explicitly used in this script
#note: this is not for direct "xz" commands, but for "tar --xz" archiving
export XZ_OPT="--verbose --threads=0 --extreme -9"

declare XARGS="xargs --max-procs 0 --max-args 1 --null	--arg-file ${CPIO_FILE}.nul"
declare CPIO_IN="cpio -v --create --format newc --null	--file ${CPIO_FILE}	--directory" #>>> ${TARGET}
declare CPIO_OUT="cpio -v --extract			--file ${CPIO_FILE}	--directory" #>>> ${CPIO_FILE}.dir
declare XZ="xz -vv --compress --stdout --format xz --check crc32"

########################################

declare PATCH="patch --force --strip=1"
declare PATCH_DIR="${ARTDIR}/patches"
declare -a PATCHES
PATCHES[0]="shmem-add-shmem_size-option-set-filesystem-size.v4.18-rc6.patch"

########################################

declare PACKDIRS_LINK="packdir"
declare PACKDIRS_DSEP="--"
declare PACKDIRS_CSEP=":"
declare PACKDIRS_PRNT="60"

#>>> for CHAR in {32..47} {58..64} {91..96} {123..126}; do printf "%3s" "${CHAR}"; printf " [\\$(printf "%0.3o" "${CHAR}")]\n"; done
#note: these must not be "[a-z]" and category names must be "[a-z]+[:]" for regular expressions to work properly
declare PACKDIRS_KEEP="*"
declare PACKDIRS_INST="+"
declare PACKDIRS_PACK="-"
declare PACKDIRS_GONE="|"
declare PACKDIRS_MARK="-"

declare PACKDIRS_DEFL="${PACKDIRS_INST}"

#note: the "$repdir" and "$ldir" directories are packed in the "prepare_repdir" and "prepare_linux" functions, respectively
#note: adding them here ensures they will be handled properly by functions like "release_reset" and "release_unpack", as though they were regular archives
for FILE in ${REPDIR} ${LDIR} ${PDBDIR}	; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSPACK+="; ${_TITLE}:${FILE}"; fi; done
for FILE in ${REPDIR}.git		; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSARCH+="; ${_TITLE}:${FILE}"; fi; done
FSEXCL+="$(${LS} ${TARGET}${MDIR} 2>/dev/null | while read -r FILE; do
	declare KEEP="false"
	for NEXT in ${KERNEL}; do
		if [[ ${FILE} == ${NEXT}-gentoo ]]; then
			KEEP="true"
		fi
	done
	if ! ${KEEP}			&& ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then echo -en "; ${_TITLE}:${MDIR}/${FILE}"; fi
done)"
if ! ${DOTEST}; then
	FSPACK="$(variable_parse FSPACK ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|;$||g" -e "s|;| ; |g")"
	FSKEEP="$(variable_parse FSKEEP ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|;$||g" -e "s|;| ; |g")"
	FSARCH="$(variable_parse FSARCH ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|;$||g" -e "s|;| ; |g")"
	FSEXCL="$(variable_parse FSEXCL ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|;$||g" -e "s|;| ; |g")"
fi

declare PACKDIRS="
$(variable_parse FSPACK ";" "" "" true)
$(variable_parse FSKEEP ";" "" "" true)
$(variable_parse FSARCH ";" "" "" true)
"
declare PACKDIRS_LIST="
${PACKDIRS}
$(variable_parse FSEXCL ";" "" "" true)
"
if ! ${DOTEST}; then
	PACKDIRS="$(variable_parse PACKDIRS "" "" "" true | sort -u)"
fi

########################################

declare ROOTFS_CPIO="${ROOTFS}"
declare ROOTFS_TEST="${DOTEST}"
if ! ${ROOTFS_CPIO}; then
	ROOTFS_TEST="false"
fi
declare ROOTFS_CUST="false"

declare ROOTFS_NAME="rootfs"
declare ROOTFS_TYPE="squashfs"
declare ROOTFS_FILE="${_RAMFS}.${ROOTFS_NAME}"
declare ROOTFS_COMP="-comp xz -b $((2**20)) -Xdict-size 100%"
declare ROOTFS_OPTS="-noappend -info -xattrs ${ROOTFS_COMP} -wildcards -ef" #>>> ${ROOTFS_FILE}.exclude"

declare ROOTFS_ROOT="/.${_TITLE}.${ROOTFS_NAME}"
declare ROOTFS_ROOT_SRC="${ROOTFS_ROOT/#\/\.//${_TITLE}\/}"
declare ROOTFS_ROOT_OPT="groot"
declare ROOTFS_FUNC="rescue"

declare ROOTFS_BUSYBOX="/bin/busybox"
declare ROOTFS_COREUTILS="/usr/bin/coreutils"
declare ROOTFS_BASH="/bin/bash"
declare ROOTFS_SHELL="/bin/sh"
declare ROOTFS_LDD="/usr/bin/ldd"
if [[ -n $(ldd ${TARGET}${ROOTFS_BASH} 2>/dev/null | ${GREP} "not a dynamic executable") ]]; then
	ROOTFS_SHELL="${ROOTFS_BASH}"
fi

declare ROOTFS_DIRTREE_PKG="$(ls ${TARGET}${PAKDIR}/sys-apps/baselayout-[.0-9]*.tbz2 2>/dev/null | sort | tail -n1)"
declare ROOTFS_DIRTREE=""
declare ROOTFS_UTILS="
${ROOTFS_BUSYBOX}
${ROOTFS_COREUTILS}
${ROOTFS_BASH}
\
/bin/grep
/bin/sed
/bin/tar
/usr/bin/make
/usr/bin/rsync
\
/bin/mount
/bin/umount
/sbin/fsck
/sbin/fsck.ext2
/sbin/fsck.ext3
/sbin/fsck.ext4
/sbin/mount.fuse
/usr/sbin/fsck.exfat
/usr/sbin/fsck.fat
/usr/sbin/fsck.vfat
/usr/sbin/mount.exfat
/usr/sbin/mount.exfat-fuse
/usr/sbin/mount.ntfs
/usr/sbin/mount.ntfs-3g
"

declare ROOTFS_FILES="
/.profile
/etc/inittab
/initrc
"
declare ROOTFS_FILE_VARS="
_TITLE
_GOVLY
_GUNPK
ROOTFS_TEST
ROOTFS_NAME
ROOTFS_TYPE
ROOTFS_ROOT
ROOTFS_ROOT_SRC
ROOTFS_ROOT_OPT
ROOTFS_FUNC
ROOTFS_BASH
ROOTFS_SHELL
"

########################################

declare REALDEV="/sbin/realdev"
declare DEVDIRS="
/dev
/mnt
/proc
/run
/sys
\
/tmp
/var/cache
/var/lock
/var/log
/var/run
/var/tmp
"

declare SKIPDIRS_GOS="
/.gitignore
/${CMTFIL}
\
/${_FINAL/#${TARGET}\/}
/${_RAMFS/#${TARGET}\/}*
\
${_GOVLY}
${_GUNPK}
${_GINST}
\
/${_GPACK/%.txt}*
\
${ARCDIR}*
${GENDIR}*
"
declare SKIPDIRS_FUN="
${DSTDIR}
${PAKDIR}
\
${LDIR}-*
"
declare SKIPDIRS="
$(variable_parse SKIPDIRS_GOS)
${PACKDIRS_MARK}
$(variable_parse SKIPDIRS_FUN)
${PACKDIRS_MARK}
$(variable_parse PACKDIRS)
${PACKDIRS_MARK}
$(variable_parse FSARCH ";" "" ".tar.xz")
${PACKDIRS_MARK}
$(variable_parse FSEXCL ";")
$(variable_parse FSEXCL ";" "" ".tar.xz")
${PACKDIRS_MARK}
$(variable_parse DEVDIRS "" "" "/.*")
$(variable_parse DEVDIRS "" "" "/*")
"
if ! ${DOTEST}; then
	SKIPDIRS="$(variable_parse SKIPDIRS | ${SED} "/^${PACKDIRS_MARK}$/d" | sort -u)"
fi

################################################################################

function common_exists {
	declare SRC_FUNC="${1}" && shift
	echo -en "\n"
	echo -en ">>> THE OUTPUT FILES OF (${SRC_FUNC}) SEEM TO ALREADY EXIST <<<\n"
	echo -en ">>> OR THE REQUIRED DIRECTORIES OR FILES ARE MISSING <<<\n"
	echo -en "\n"
	${LL} --directory "${@}"
	echo -en "\n"
	return 0
}

########################################

function common_tar {
	declare SRC_FILE="${1}" && shift
	if [[ ! -f ${SRC_FILE}.tar.xz ]] && [[ -d ${SRC_FILE} ]] && [[ ! -L ${SRC_FILE} ]]; then
		tar -cvv --xz				\
			-C $(dirname ${SRC_FILE})	\
			-f ${SRC_FILE}.tar.xz		\
			${@}				\
			$(basename ${SRC_FILE})		|| return 1
	else
		common_exists ${FUNCNAME}		\
			${SRC_FILE}.tar.xz ${SRC_FILE}	|| return 1
	fi
	return 0
}

########################################

function common_untar {
	declare SRC_FILE="${1}" && shift
	if [[ -f ${SRC_FILE}.tar.xz ]] && [[ ! -d ${SRC_FILE} ]] && [[ ! -L ${SRC_FILE} ]]; then
		FILE="$(dirname ${SRC_FILE})"
		${MKDIR} ${FILE}			|| return 1
		tar -vvx --xz				\
			-C ${FILE}			\
			-f ${SRC_FILE}.tar.xz		\
			${@}				|| return 1
	else
		common_exists ${FUNCNAME}		\
			${SRC_FILE}.tar.xz ${SRC_FILE}	|| return 1
	fi
	return 0
}

########################################

function common_packdir {
	declare SRC_FILE="${1}" && shift
	echo "${_RAMFS/#${_FINAL}\/}.${PACKDIRS_LINK}${SRC_FILE//\//${PACKDIRS_DSEP}}.tar.xz"
	return 0
}

########################################

function common_packdirs_list {
	${LL} --directory $(
		variable_parse PACKDIRS_LIST "" "${TARGET}"				| sort -u
		variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz"			| sort -u
	)												2>/dev/null
	echo -en "\n"; ${DU_L} $(variable_parse PACKDIRS_LIST "" "${TARGET}"		| sort -u)	2>/dev/null
	echo -en "\n"; ${DU_L} $(variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz"	| sort -u)	2>/dev/null
	return 0
}

################################################################################

#NOTE: CONSULT THE "SYSTEM INSTALLATION" TABLE IN "README" FOR THIS SECTION

#note: this is called statically in the "_system" script
#note: cross-reference with the "release_install" function any time this changes
function _release_reset {		#{main}
	${RM} ${TARGET}/${CMTFIL}				|| return 1
	${RM} ${TARGET}/${_GPACK/%.txt}*			|| return 1
	${RM} ${TARGET}/.gitignore				|| return 1
	if [[ -n ${TARGET} ]]; then
		${RM} ${TARGET}/{.,_}${_TITLE}*			|| return 1
	fi
	FILE="$(findmnt --noheadings --output TARGET --target ${_FINAL})"
	if [[ ${FILE} != ${_FINAL} ]] && [[ ! -L ${_FINAL} ]]; then
		${RM} ${_FINAL}*				|| return 1
	else
		${RM} ${_RAMFS}*				|| return 1
	fi
	if [[ -n ${TARGET} ]]; then
		_prepare_packdirs ${_RST}			|| return 1
	fi
	if [[ -n ${TARGET} ]] && [[ ${TARGET} != ${_GINST} ]]; then
		${RM}		${TARGET}${LDIR}		|| return 1
		${LN} ${KBAS}	${TARGET}${LDIR}		|| return 1
		_prepare_config ${_RST}				|| return 1
	fi
	return 0
}

########################################

function _release_review {		#{main}
	if ${DO_CHROOT} && [[ -n ${TARGET} ]]; then
		${_SOUL} ${QUIET_OPT} ${TOOR} -r				|| return 1
		echo -en "\n"
#>>>		safe_env ${MYSELF} ${QUIET_OPT} ${TOOR} ${FUNCNAME}		|| return 1
		declare SAFE_ENV_ORIG="${SAFE_ENV}"
		export SAFE_ENV+=" IS_CHROOT=\"false\" GOSDIR=\"/\" FSPACK=\"\" FSKEEP=\"\" FSARCH=\"\" FSEXCL=\"\""
		safe_env ${MYSELF} ${QUIET_OPT} -g ${FUNCNAME}			|| return 1
		SAFE_ENV="${SAFE_ENV_ORIG}"
#>>>
		return 0
	fi
	variable_parse SKIPDIRS
	read FILE
	#note: total filesystem size with all directories unpacked (completely loaded memory size)
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match PACKDIRS "" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: initial rootfs size with "$fspack" and "$fskeep" still packed (kernel size)
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSPACK ";" "${FILE}" true ||
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSPACK ";" "${FILE}" true ||
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: loaded rootfs size with "$fspack" unpacked and "$fskeep" still packed (memory size)
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				if {
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}\""
				fi
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: final rootfs size with both "$fspack" and "$fskeep" unpacked (maximum memory size)
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	echo -en "\n[FSPACK]\n"; variable_parse FSPACK ";" | sort -u
	echo -en "\n[FSKEEP]\n"; variable_parse FSKEEP ";" | sort -u
	echo -en "\n[FSARCH]\n"; variable_parse FSARCH ";" | sort -u
	echo -en "\n[FSEXCL]\n"; variable_parse FSEXCL ";" | sort -u
	echo -en "\n"; common_packdirs_list
	return 0
}

################################################################################

function _prepare_build {		#{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	if [[ -n ${RESET} ]]; then
		shift
		DOREDO="false" _release_reset	|| return 1
	fi
	if ! ${DOFAST}; then
		DOREDO="false" _prepare_config	|| return 1
	fi
	DOREDO="false" _prepare_docdir		|| return 1
	DOREDO="false" _prepare_repdir		|| return 1
	DOREDO="false" _prepare_linux		|| return 1
	DOREDO="false" _prepare_packdirs	|| return 1
	DOREDO="false" _prepare_packages	|| return 1
	DOREDO="false" _prepare_symlinks	|| return 1
	return 0
}

########################################

function prepare_config_issue {
	declare FUNTOO_DATE="$(${SED} -n "s|^#.+([0-9]{4}-[0-9]{2}-[0-9]{2}).+(${FUNTOO}).*$|\1|gp" ${SETDIR}/${FUNDIR}/${FUNCMT})"
	for FILE in \
		"GaryOS Version|${_VERSN}" \
		"GaryOS Release Date|${_RDATE}" \
		"Funtoo Commit Date|${FUNTOO_DATE}" \
		"Funtoo Commit|${FUNTOO}" \
		"Linux Kernel|${KVER}" \
	; do
		declare KEY="$(echo "${FILE}" | ${SED} "s|^(.+)[|](.+)$|\1|g")"
		declare VAL="$(echo "${FILE}" | ${SED} "s|^(.+)[|](.+)$|\2|g")"
		${SED} -i \
			-e "s|^(.*${KEY}[:].*[0-9]m ).*$|\1${VAL}|g" \
			${ARTDIR}/files/issue \
			|| return 1
	done
	${RSYNC_C} --copy-links ${ARTDIR}/files/issue ${TARGET}/etc/issue \
		|| return 1
	if
	[[ -z ${COMMIT} ]] ||
	[[ ${_PKG} != ${GOSPKG} ]] ||
	[[ -z ${TARGET} ]]
	then
		FILE=" "
#>>>		FILE+="\\\e[1;45;37m"
		FILE+="\\\e[0;35m"
		FILE+="PLEASE NOTE THAT THIS BUILD HAS BEEN CUSTOMIZED AND IS NOT AN OFFICIAL RELEASE"
		FILE+="\\\e[0;37m"
		${SED} -i "/Some helpful notes/,/More information/c\\${FILE}" \
			${TARGET}/etc/issue \
			|| return 1
	fi
	${SED} \
		-e "s|[\]e[[]([0-9]+[;])?[0-9]+[;][0-9]+m||g" \
		-e "/^[\][a-z]/d" \
		${TARGET}/etc/issue >${TARGET}/etc/motd \
		|| return 1
	return 0
}

function prepare_config_restore {	#>>>{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	declare PACK="${1}" && shift
	declare PFIL="${1}" && shift
	declare PSRC="${1}" && shift
	FILE="$(ls ${TARGET}${PAKDIR}/${PACK}-[.0-9]*.tbz2 2>/dev/null | sort | tail -n1)"
	if {
		[[ -n ${PACK} ]] &&
		[[ -f ${FILE} ]]
	}; then
		echo -en "\n"
		echo -en ">>> RESTORING (${PFIL}) FROM (${PACK}) PACKAGE FILE <<<\n"
		echo -en "\n"
		NEXT=".${PFIL}"
		if [[ -n ${PSRC} ]]; then
			NEXT="$(tar -t --bzip2 --wildcards -f ${FILE} "*/${PSRC}" | sort | tail -n1)"
			if [[ -z ${NEXT} ]]; then
				return 1
			fi
		fi
		tar -vvx --bzip2 -C ${TARGET} -f ${FILE} ${NEXT}		|| return 1
		if [[ -n ${PSRC} ]]; then
			NEXT="${NEXT/#.}"
			if [[ -n $(file ${TARGET}${NEXT} | ${GREP} "bzip2") ]]; then
				bzip2 -cd ${TARGET}${NEXT} >${TARGET}${PFIL}	|| return 1
			else
				${RSYNC_U} ${TARGET}${NEXT} ${TARGET}${PFIL}	|| return 1
			fi
		fi
		${RSYNC_U} ${TARGET}${PFIL} ${TARGET}${PFIL}.${_TITLE}		|| return 1
	elif {
		[[ -f ${PFIL}.${_TITLE} ]]
	}; then
		echo -en "\n"
		echo -en ">>> RESTORING (${PFIL}) FROM (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en "\n"
		${RSYNC_U} ${TARGET}${PFIL}.${_TITLE} ${TARGET}${PFIL}		|| return 1
	elif {
		[[ -n $(${GREP} "^${PACK}$" ${TARGET}${ETCDIR}/sets/${_PKG}) ]] ||
		[[ -n $(safe_env equery list '*' 2>&1 | ${GREP} "^${PACK}-[0-9]") ]]
	}; then
		echo -en "\n"
		echo -en ">>> NO (${PACK}) PACKAGE FILE OR (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en ">>> BUT THERE IS A (${PACK}) ENTRY IN THE (${_PKG}) SET OR IT IS INSTALLED <<<\n"
		echo -en ">>> LEAVING (${PFIL}) ALONE <<<\n"
		echo -en "\n"
	else
		echo -en "\n"
		echo -en ">>> NO (${PACK}) PACKAGE FILE OR (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en ">>> NO (${PACK}) ENTRY IN THE (${_PKG}) SET AND IT IS NOT INSTALLED <<<\n"
		echo -en ">>> REMOVING (${PFIL}) FILE <<<\n"
		echo -en "\n"
		${RM} ${TARGET}${PFIL}						|| return 1
	fi
	if [[ -n ${RESET} ]]; then
		${RM} ${TARGET}${PFIL}.${_TITLE}				|| return 1
	fi
	return 0
}

#NOTE: UPDATE THE "SYSTEM INSTALLATION" TABLE IN "README" WHEN MAKING CHANGES HERE

#note: this is called statically in the "_system" script
function _prepare_config {		#{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	#note: these are from the "prepare_config_issue" function above
	prepare_config_restore ${RESET} sys-apps/baselayout		/etc/issue				|| return 1
	prepare_config_restore ${RESET} ""				/etc/motd				|| return 1
	#note: these are all directly below
	prepare_config_restore ${RESET} ""				/init					|| return 1
	prepare_config_restore ${RESET} sys-apps/baselayout		/etc/fstab				fstab			|| return 1
	prepare_config_restore ${RESET} sys-libs/glibc			/etc/locale.gen				|| return 1
	prepare_config_restore ${RESET} sys-apps/openrc			/etc/conf.d/hostname			|| return 1
	prepare_config_restore ${RESET} ""				/etc/profile.d/setterm.sh		|| return 1
	prepare_config_restore ${RESET} net-wireless/wpa_supplicant	/etc/wpa_supplicant/wpa_supplicant.conf	wpa_supplicant.conf.bz2	|| return 1
	prepare_config_restore ${RESET} net-misc/openssh		/etc/ssh/sshd_config			|| return 1
	prepare_config_restore ${RESET} ""				/etc/env.d/90xsession			|| return 1
	prepare_config_restore ${RESET} x11-wm/dwm			/etc/X11/Sessions/dwm			|| return 1
	if [[ -n ${RESET} ]]; then
		${SED} -i "s|^[#](en_US)|\1|g"				${TARGET}/etc/locale.gen		|| return 1
		safe_env						/usr/sbin/locale-gen			|| return 1
		return 0
	fi
	shopt -s lastpipe
	variable_parse RCUPDT ";" | while read -r FILE; do
		eval safe_env						${FILE}					|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	prepare_config_issue											|| return 1
	${LN} sbin/init							${TARGET}/init				|| return 1
	${SED} -i "s|^([^#].+)$|#\1|g"					${TARGET}/etc/fstab			|| return 1
	${RSYNC_C} --copy-links ${ARTDIR}/files/locale.gen		${TARGET}/etc/				|| return 1
	${SED} -i "s|^(hostname=[\"]?)[^\"]+([\"]?)$|\1${_TITLE}\2|g"	${TARGET}/etc/conf.d/hostname		|| return 1
	echo -en "setterm -blength 0\n"					>${TARGET}/etc/profile.d/setterm.sh	|| return 1
	${RSYNC_C} --copy-links ${ARTDIR}/files/wpa_supplicant.conf	${TARGET}/etc/wpa_supplicant/		|| return 1
	${SED} -i "s|^.*(PermitRootLogin).*$|\1 yes|g"			${TARGET}/etc/ssh/sshd_config		|| return 1
	echo -en "XSESSION=\"${WINMGR}\"\n"				>${TARGET}/etc/env.d/90xsession		|| return 1
	FILE=													|| return 1
		FILE+="xset -b\n"										|| return 1
		FILE+="xsetroot -mod 3 3 -fg '#000000' -bg '#404040'\n"						|| return 1
	${SED} -i												\
		-e "/xset[ ][-]b/d"										\
		-e "/xsetroot[ ][-]mod/d"									\
		-e "s|^(exec[ ].*)$|${FILE}\1|g"								\
									${TARGET}/etc/X11/Sessions/dwm		|| return 1
	${SED} -i "s|^(.*xsetroot[ ][-]name[ ]).*$|\1\"${WMHELP}\"|g"	${TARGET}/etc/X11/Sessions/dwm		|| return 1
	safe_env							/usr/sbin/locale-gen			|| return 1
	safe_env							/usr/sbin/env-update			|| return 1
	echo -en "${_TITLE}\n${_TITLE}\n" | safe_env			/usr/bin/passwd root			|| return 1
	return 0
}

########################################

function _prepare_docdir {
	if [[ ! -d ${_G_REPO} ]] || [[ ! -d ${_G_REPO}.git ]]; then
#>>>		${RM}							${TARGET}/.${_TITLE}			|| return 1
		return 0
	fi
	${MKDIR}							${TARGET}/.${_TITLE}			|| return 1
	if ${DOTEST} && {
		[[ -s ${SETDIR}/.gitignore ]] &&
		[[ -s ${SETDIR}/Makefile ]];
	}; then
		eval ${RSYNC_U} --copy-links --delete-excluded							\
			--filter="-_/.git"									\
			--filter="P_/.git"									\
			$(${GREP} -v -e "^[#]" -e "^$" ${SETDIR}/.gitignore | while read -r FILE; do
				echo "--filter=\"-_${FILE/%\/}\""
			done)											\
			${SETDIR}/					${TARGET}/.${_TITLE}			|| return 1
	else
		${RSYNC_U} --filter="-_/.git" ${_G_REPO}/		${TARGET}/.${_TITLE}			|| return 1
	fi
	${RSYNC_U} ${_G_REPO}.git/					${TARGET}/.${_TITLE}/.git		|| return 1
	${SED} -i "/worktree[ ][=]/d"					${TARGET}/.${_TITLE}/.git/config	|| return 1
	${RM}								${TARGET}/.${_TITLE}/build		|| return 1
	${LN} "/"							${TARGET}/.${_TITLE}/build		|| return 1
	#note: the configuration files need to match the current state when everything is unpacked
	portage_file							${TARGET}/.${_TITLE}/gentoo		|| return 1
	#note: same with the selected package set in the makefile
	${SED} -i "s|^(override P[[:space:]]+[?][=][ ]).+$|\1${_PKG}|g"	${TARGET}/.${_TITLE}/Makefile		|| return 1
	return 0
}

########################################

function _prepare_repdir {
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	REP_FILE="${TARGET}${ARCDIR}/$(basename ${REPDIR})"
	if [[ -f ${REP_FILE}.tar.xz ]] && [[ -f ${REP_FILE}.git.tar.xz ]]; then
		${RSYNC_U} ${REP_FILE}.tar.xz			${TARGET}${REPDIR}.tar.xz		|| return 1
		${RSYNC_U} ${REP_FILE}.git.tar.xz		${TARGET}${REPDIR}.git.tar.xz		|| return 1
	fi
	if [[ ! -f ${TARGET}${REPDIR}.tar.xz ]] || [[ ! -f ${TARGET}${REPDIR}.git.tar.xz ]]; then
		${RM}						${REP_FILE}{,.git}.tar.xz		|| return 1
		${RM}						${TARGET}${REPDIR}{,.git}{,.tar.xz}	|| return 1
		if [[ -d ${GITDIR} ]]; then
			${MKDIR}				${TARGET}${REPDIR}.git			|| return 1
			${RSYNC_U} ${GITDIR}/			${TARGET}${REPDIR}.git			|| return 1
		fi
		safe_env ${MYSELF} ${QUIET_OPT} ${TOOR} ${AUTO} ${FUNTOO}				|| return 1
		common_tar					${TARGET}${REPDIR}			|| return 1
		common_tar					${TARGET}${REPDIR}.git			|| return 1
	fi
	if [[ ! -d ${TARGET}${REPDIR} ]] || [[ ! -d ${TARGET}${REPDIR}.git ]]; then
		${RM}						${TARGET}${REPDIR}{,.git}		|| return 1
		common_untar					${TARGET}${REPDIR}			|| return 1
		common_untar					${TARGET}${REPDIR}.git			|| return 1
	fi
	if [[ ! -f ${REP_FILE}.tar.xz ]] || [[ ! -f ${REP_FILE}.git.tar.xz ]]; then
		${RSYNC_U} ${TARGET}${REPDIR}.tar.xz		${REP_FILE}.tar.xz			|| return 1
		${RSYNC_U} ${TARGET}${REPDIR}.git.tar.xz	${REP_FILE}.git.tar.xz			|| return 1
	fi
	return 0
}

########################################

function prepare_linux_directory {
	declare DODIR="${1}" && shift
	if [[ ! -d ${TARGET}${DODIR} ]]; then
		${RM}						${TARGET}${DODIR}.${_TITLE}	|| return 1
		${MKDIR}					${TARGET}${DODIR}.${_TITLE}	|| return 1
		tar -vvx --bzip2								\
			-C ${TARGET}${DODIR}.${_TITLE}						\
			-f ${TARGET}${PAKDIR}/*/gentoo-sources-${KVER}.tbz2			|| return 1
		${MV} ${TARGET}${DODIR}.${_TITLE}${KDIR}	${TARGET}${DODIR}		|| return 1
		${RM}						${TARGET}${DODIR}.${_TITLE}	|| return 1
		safe_env make -C ${DODIR}			distclean			|| return 1
	fi
	return 0
}

function _prepare_linux {
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	if [[ ! -f ${TARGET}${LDIR}.tar.xz ]]; then
		${RM}					${TARGET}${LDIR}		|| return 1
#>>>		prepare_linux_directory			${TARGET}${LDIR}		|| return 1
		prepare_linux_directory			${LDIR}				|| return 1
		${RSYNC_U} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${LDIR}/.config	|| return 1
		safe_env make -C ${LDIR}		modules_prepare			|| return 1
		common_tar				${TARGET}${LDIR}		|| return 1
	fi
	return 0
}

########################################

#note: companion to the "release_unpack" function
function _prepare_packdirs {		#{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	if [[ -n ${RESET} ]]; then
		${RM} $(variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz")
		NEXT="$(eval find ${TARGET} \
			$(variable_parse DEVDIRS "" "\\( -path ${TARGET}" " -prune \\) -o ") \
			\\\( -path ${_FINAL} -prune \\\) -o \
			\\\( -path ${TARGET}${ARCDIR} -prune \\\) -o \
			\\\( -path ${TARGET}${DSTDIR} -prune \\\) -o \
			\\\( -path ${TARGET}${PAKDIR} -prune \\\) -o \
			-print |
			${GREP} "[.]tar[.]xz$"
		)"
		if [[ -n ${NEXT} ]]; then
			${LL} ${NEXT} | ${GREP} "[^/]+[.]tar[.]xz$"
			return 1
		fi
		return 0
	fi
	shopt -s lastpipe
	#note: packing them in reverse, so that embedded packdirs get included
	variable_parse PACKDIRS | sort -r | while read -r FILE; do
		eval common_tar ${TARGET}${FILE} $(
			variable_parse FSEXCL ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
					echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
				fi
			done
			variable_parse FSARCH ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
					echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
				fi
			done
			variable_parse FSKEEP ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
				fi
			done
			variable_parse FSPACK ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
				fi
			done
		) || return 1
	done
	shopt ${LASTPIPE} lastpipe
	echo -en "\n"; common_packdirs_list
	return 0
}

########################################

function _prepare_packages {
	declare PACK_FILE="${_GPACK}"
	if ${ROOTFS_CUST}; then
		PACK_FILE="${_GPACK/%.txt/.${ROOTFS_NAME}.txt}"
	fi
	if [[ -z ${TARGET} ]]; then
		${RM} ${TARGET}/${PACK_FILE}								|| return 1
		return 0
	fi
	cat /dev/null >${TARGET}/${PACK_FILE}								|| return 1
	for FILE in $(
		cd ${TARGET}${PAKDIR}									&&
		find ./ -mindepth 2 -maxdepth 2 -type f							|
			${SED} "s|^[.][/]||g"								|
			sort -u
	); do
		declare PKG_DB="$(cd ${TARGET}${PDBDIR} && ${LS} -d ${FILE/%.tbz2}	2>/dev/null)"	|| return 1
		declare PKG_DU="$(cd ${TARGET}${PAKDIR} && ${DU} -ks ${FILE}		2>/dev/null)"	|| return 1
		if [[ -n ${PKG_DB} ]]; then
			echo -en "${PKG_DU} (installed)\n"	| tee -a ${TARGET}/${PACK_FILE}		|| return 1
		else
			echo -en "${PKG_DU} (packaged)\n"	| tee -a ${TARGET}/${PACK_FILE}		|| return 1
		fi
	done
	return 0
}

########################################

#note: companion to the "release_fetch" function
function _prepare_symlinks {		#{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	REP_FILE="$(basename ${REPDIR})"
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	if [[ -n ${COMMIT} ]]
		#note: also doing this in "_system" script on purpose
		then echo -en "${COMMIT}"				>${TARGET}/${CMTFIL}				|| return 1
		else ${RM}						${TARGET}/${CMTFIL}				|| return 1
	fi
	${MKDIR} ${_FINAL}												|| return 1
	${RM} $(find							${_FINAL} -maxdepth 1 -type l | sort)		|| return 1
	if [[ -n ${RESET} ]]; then
		return 0
	fi
	${LN} --relative ${TARGET}/.${_TITLE}/README.md			${_RAMFS}.${_GREAD}				|| return 1
	${LN} --relative ${TARGET}/${_GPACK}				${_RAMFS}.kernel.${_GPACK}			|| return 1
	${LN} --relative ${TARGET}/${_GPACK/%.txt/.${ROOTFS_NAME}.txt}	${_RAMFS}.${ROOTFS_NAME}.${_GPACK}		|| return 1
	${LN} --relative ${TARGET}${DSTDIR}				${_FINAL}/_$(basename ${DSTDIR})		|| return 1
	${LN} --relative ${TARGET}${PAKDIR}				${_FINAL}/_$(basename ${PAKDIR})		|| return 1
	${LN} --relative ${TARGET}${ARCDIR}/${REP_FILE}.tar.xz		${_RAMFS}.${REP_FILE}.tar.xz			|| return 1
	${LN} --relative ${TARGET}${ARCDIR}/${REP_FILE}.git.tar.xz	${_RAMFS}.${REP_FILE}.git.tar.xz		|| return 1
	shopt -s lastpipe
	variable_parse PACKDIRS | while read -r FILE; do
		${LN} --relative ${TARGET}${FILE}.tar.xz		${_FINAL}/$(common_packdir ${FILE})		|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	for FILE in ${TARGET}${ARCDIR}/stage3-*.tar.xz; do
		${LN} --relative ${FILE}				${_FINAL}/					|| return 1
	done
	return 0
}

################################################################################

function _release_ramfs {		#{main} #{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	DOREDO="false" _prepare_build	${RESET}	|| return 1
	DOREDO="false" _release_cpio			|| return 1
	DOREDO="false" _release_kernel			|| return 1
	DOREDO="false" _release_grub			|| return 1
	DOREDO="false" _release_report			|| return 1
	return 0
}

########################################

function release_rootfs_cpio_utils {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	for FILE in ${ROOTFS_UTILS}; do
		${MKDIR}				${ROOTFS_DEST}.dir$(dirname ${FILE})	|| return 1
		${RSYNC_U} --copy-links			${TARGET}${FILE}			\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		for NEXT in $(
			chroot ${TARGET} ${ROOTFS_LDD}	${FILE}					|
			${GREP} --only-matching		"[/][^[:space:]]+"			\
		); do
			${MKDIR}			${ROOTFS_DEST}.dir$(dirname ${NEXT})	|| return 1
			${RSYNC_U} --copy-links		${TARGET}${NEXT}			\
							${ROOTFS_DEST}.dir${NEXT}		|| return 1
		done
	done
	return 0
}

function release_rootfs_cpio_tools {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	declare BUSY_DIR="$(dirname			${ROOTFS_BUSYBOX})"
	${MKDIR}					${ROOTFS_DEST}.dir${BUSY_DIR}		|| return 1
	(chroot ${ROOTFS_DEST}.dir ${ROOTFS_BUSYBOX}	--install -s ${BUSY_DIR})		|| return 1
	declare CORE_DIR="$(dirname			${ROOTFS_COREUTILS})"
	${MKDIR}					${ROOTFS_DEST}.dir${CORE_DIR}		|| return 1
	for FILE in $(
		${TARGET}${ROOTFS_COREUTILS} --help | ${GREP} "^[[:space:]]*[[]"
	); do
		${LN} --relative			${ROOTFS_DEST}.dir${ROOTFS_COREUTILS}	\
							${ROOTFS_DEST}.dir${BUSY_DIR}/${FILE}	|| return 1
		${LN} --relative			${ROOTFS_DEST}.dir${ROOTFS_COREUTILS}	\
							${ROOTFS_DEST}.dir${CORE_DIR}/${FILE}	|| return 1
	done
	return 0
}

function release_rootfs_cpio_files {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	for FILE in ${ROOTFS_FILES}; do
		${MKDIR}				${ROOTFS_DEST}.dir$(dirname ${FILE})	|| return 1
		${RSYNC_C} --copy-links			${ARTDIR}/files/$(basename ${FILE})	\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		for NEXT in ${ROOTFS_FILE_VARS}; do
			${SED} -i "s|[$][{]${NEXT}[}]|${!NEXT}|g"				\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		done
	done
	return 0
}

function release_rootfs_cpio {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	${RM}						${ROOTFS_DEST}.dir			|| return 1
#>>>	tar -xvvf ${ROOTFS_DIRTREE_PKG} --directory	${ROOTFS_DEST}.dir			|| return 1
	for FILE in ${ROOTFS_DIRTREE}; do
		${MKDIR}				${ROOTFS_DEST}.dir${FILE}		|| return 1
	done
	${MKDIR}					${ROOTFS_DEST}.dir/dev			|| return 1
	${TARGET}${REALDEV}				${ROOTFS_DEST}.dir/dev			|| return 1
	#note: need "utils" first to get the "tools" before unpacking them
	#note: then need "utils" again to overwrite/update key binaries
	release_rootfs_cpio_utils			${ROOTFS_DEST}				|| return 1
	release_rootfs_cpio_tools			${ROOTFS_DEST}				|| return 1
	release_rootfs_cpio_utils			${ROOTFS_DEST}				|| return 1
	release_rootfs_cpio_files			${ROOTFS_DEST}				|| return 1
	if [[ -d ${ROOTFS_DEST}.dir/lib64 ]]; then
		${LN} --relative			${ROOTFS_DEST}.dir/lib64		\
							${ROOTFS_DEST}.dir/lib			|| return 1
	fi
	${LN} --relative				${ROOTFS_DEST}.dir${ROOTFS_BUSYBOX}	\
							${ROOTFS_DEST}.dir/init			|| return 1
	echo -en "\n"
	${DU_L}						${ROOTFS_DEST}.dir			|| return 1
	(cd ${ROOTFS_DEST}.dir && ${LL} --directory	$(find ./ ! -type l))			|| return 1
	${RSYNC_U} ${ROOTFS_DEST}			${ROOTFS_DEST}.dir${ROOTFS_ROOT}	|| return 1
	return 0
}

function release_rootfs_file {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	${MKDIR}			$(dirname ${ROOTFS_DEST})				|| return 1
	cat /dev/null			>${ROOTFS_DEST}.exclude					|| return 1
	variable_parse SKIPDIRS | ${SED}							\
					-e "s|^/||g"						\
					>>${ROOTFS_DEST}.exclude				|| return 1
	${SED} -i "/^dev\//d"		${ROOTFS_DEST}.exclude					|| return 1
	${RM}				${TARGET}/tmp/${_TITLE}.dev				|| return 1
	${MKDIR}			${TARGET}/tmp/${_TITLE}.dev				|| return 1
	${TARGET}${REALDEV}		${TARGET}/tmp/${_TITLE}.dev				|| return 1
	for FILE in $(cd		${TARGET}/dev && find ./); do				declare SKIP="true"
		for NEXT in $(cd	${TARGET}/tmp/${_TITLE}.dev && find ./); do		if [[ ${FILE} == ${NEXT} ]]; then SKIP="false"; fi
		done;										if ${SKIP}; then echo "${FILE/#\./dev}"; fi
	done				>>${ROOTFS_DEST}.exclude				|| return 1
	${RM}				${TARGET}/tmp/${_TITLE}.dev				|| return 1
	mk${ROOTFS_TYPE} ${TARGET}	${ROOTFS_DEST} ${ROOTFS_OPTS} ${ROOTFS_DEST}.exclude	|| return 1
	un${ROOTFS_TYPE} -lls		${ROOTFS_DEST} >${ROOTFS_DEST}.txt			|| return 1
	return 0
}

function _release_rootfs {		#{main} #{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	if [[ -n ${RESET} ]]; then
		${RM}						${ROOTFS_DEST}*	|| return 1
	fi
	if [[ ${ROOTFS_DEST} == ${ROOTFS_FILE} ]]; then
		ROOTFS_CUST="true"
		if [[ -n ${RESET} ]]; then
			DOREDO="false" _prepare_symlinks	${RESET}	|| return 1
			DOREDO="false" _prepare_packdirs	${RESET}	|| return 1
		fi
		DOREDO="false" DOFAST="false" _prepare_build			|| return 1
	fi
	if [[ ! -f ${ROOTFS_DEST} ]]; then
		${RM}						${CPIO_FILE}	|| return 1
		release_rootfs_file				${ROOTFS_DEST}	|| return 1
		release_rootfs_cpio				${ROOTFS_DEST}	|| return 1
	elif ${ROOTFS_TEST}; then
		release_rootfs_cpio				${ROOTFS_DEST}	|| return 1
	else
		common_exists ${FUNCNAME}			${ROOTFS_DEST}*	|| return 1
	fi
	return 0
}

########################################

function release_cpio_nul {
	if ${ROOTFS_CPIO}; then
		if ! ${ROOTFS_TEST}; then
			_release_rootfs ${_RST}			${CPIO_FILE}.${ROOTFS_NAME}	|| return 1
		else
			_release_rootfs				${CPIO_FILE}.${ROOTFS_NAME}	|| return 1
		fi
		(cd ${CPIO_FILE}.${ROOTFS_NAME}.dir && eval find ./ -mindepth 1 -xdev \
		-print0)					>${CPIO_FILE}.nul		|| return 1
	else
		(cd ${TARGET} && eval find ./ -mindepth 1 -xdev \
			$(for FILE in $(
				variable_parse SKIPDIRS | ${SED} \
								-e "s|\*|\\\*|g" \
				); do				echo "\\( -path .${FILE} -prune \\) -o"; done
			) \
		-print0)					>${CPIO_FILE}.nul		|| return 1
		${RM}						${TARGET}/tmp/dev		|| return 1
		${MKDIR}					${TARGET}/tmp/dev		|| return 1
		${TARGET}${REALDEV}				${TARGET}/tmp/dev		|| return 1
		(cd ${TARGET}/tmp && find ./dev -print0)	>>${CPIO_FILE}.nul		|| return 1
		${RM}						${TARGET}/tmp/dev		|| return 1
	fi
	return 0
}

function release_cpio_file {
	if ${ROOTFS_CPIO}; then
		(cd ${CPIO_FILE}.${ROOTFS_NAME}.dir && ${XARGS} ${DU_S})	| tee ${CPIO_FILE}.txt
		cat ${CPIO_FILE}.nul | ${CPIO_IN}				${CPIO_FILE}.${ROOTFS_NAME}.dir	|| return 1
	else
		(cd ${TARGET} && ${XARGS} ${DU_S})				| tee ${CPIO_FILE}.txt
		cat ${CPIO_FILE}.nul | ${CPIO_IN}				${TARGET}			|| return 1
	fi
	sort -k4 -u -o ${CPIO_FILE}.txt						${CPIO_FILE}.txt		|| return 1
	${RM}									${CPIO_FILE}.nul		|| return 1
	return 0
}

function release_cpio_dir {
	if [[ -n ${TARGET} ]]; then
		if ! ${ROOTFS_CPIO}; then
			${RM}			${CPIO_FILE}.dir	|| return 1
			${MKDIR}		${CPIO_FILE}.dir	|| return 1
			${CPIO_OUT}		${CPIO_FILE}.dir	|| return 1
		fi
		if ! ${ROOTFS_TEST}; then
			${XZ} ${CPIO_FILE}	>${CPIO_FILE}.xz	|| return 1
		fi
	fi
	return 0
}

function _release_cpio {
	mount_dev_dirs -u				|| return 1
	${MKDIR} ${_FINAL}				|| return 1
	if [[ ! -f ${CPIO_FILE} ]]; then
		${RM} ${_RAMFS}.kernel			|| return 1
		release_cpio_nul			|| return 1
		release_cpio_file			|| return 1
		release_cpio_dir			|| return 1
	else
		common_exists ${FUNCNAME} ${CPIO_FILE}*	|| return 1
	fi
	return 0
}

########################################

function release_kernel_patch {
	declare DODIR="${1}" && shift
	for FILE in ${PATCHES[*]}; do
		${PATCH} --directory=${TARGET}${DODIR} --reverse <${PATCH_DIR}/${FILE}	#>>> || return 1
		${PATCH} --directory=${TARGET}${DODIR} <${PATCH_DIR}/${FILE}		|| return 1
	done
	return 0
}

function release_kernel_config {
	declare DODIR="${1}" && shift
	if [[ -z ${TARGET} ]]; then	${RSYNC_U} ${SETDIR}/${LINDIR}/${KCFG}	${TARGET}${DODIR}/.config	|| return 1
	else				${RSYNC_U} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${DODIR}/.config	|| return 1
	fi
	kernel_cpu								${TARGET}${DODIR}/.config	|| return 1
	return 0
}

function release_kernel_shmem {
	declare DODIR="${1}" && shift
	#note: treating the size of the ".cpio" as the in-memory filesystem size, adding buffer and free disk space, and then rounding pages
	#note: the "$fspack" directories are ".tar.xz" compressed, so also calculating their final cost once they are unpacked and the archives are deleted
	#note: the "$fspack" calculation also factors in the status of subdirectories
	#note: none of this is perfect, but it is close enough
	declare SHMEM_PAGES="4096"
	declare SHMEM_MEM="${SHMEM_MEM}*(1024^2)"
	declare SHMEM="$(${DU_S} ${CPIO_FILE} | ${SED} "s|[[:space:]].*$||g")"
	declare PRINTF=" %10.10s %10.10s %10.10s %10.10s %10.10s\n"
	printf "%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s" ">>> INITIAL SHMEM: ${SHMEM}"
	printf "${PRINTF}" "~ SIZE" "+ COST" "- PACK" "@ DIFF" "= SHMEM"
	shopt -s lastpipe
	variable_parse FSPACK ";" | while read -r FILE; do
		#note: the "if" subshell is to work around a "lastpipe" error when the last item in the "$fspack" list is excluded
		if [[ -n $(if {
			! variable_match FSKEEP FSARCH FSEXCL ";" "${FILE}" &&
			! variable_match FSKEEP FSARCH FSEXCL ";" "${FILE}" true;
		}; then
			echo "true"
		fi) ]]; then
			printf "%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s" ">>> PACKDIR: ${FILE}"
			if [[ ! -d ${TARGET}${FILE} ]] || [[ ! -f ${TARGET}${FILE}.tar.xz ]]; then
				echo -en "\n"
				common_exists ${FUNCNAME} ${TARGET}${FILE} ${TARGET}${FILE}.tar.xz
				return 1
			fi
			declare S_VAL="$(${DU_S} ${TARGET}${FILE}		2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			declare S_ADD="$(eval ${DU_S} ${TARGET}${FILE} $(
				variable_parse FSEXCL | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
				variable_parse FSARCH | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
				variable_parse FSKEEP | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
					fi
				done
				variable_parse FSPACK | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
			)							2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			declare S_SUB="$(${DU_S} ${TARGET}${FILE}.tar.xz	2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			declare S_TOT="$(echo "${S_ADD}-${S_SUB}" | bc)"
			SHMEM="$(echo "${SHMEM}+${S_TOT}" | bc)"
			printf "${PRINTF}" "${S_VAL}" "${S_ADD}" "${S_SUB}" "${S_TOT}" "${SHMEM}"
		fi
	done
	shopt ${LASTPIPE} lastpipe
	echo -en ">>> TOTAL SHMEM: ${SHMEM}\n"
	SHMEM="$(echo "((${SHMEM}+(${SHMEM_MEM}))/${SHMEM_PAGES})" | bc | ${SED} -r "s|[.].*$||g")"
	SHMEM="$(echo "(${SHMEM}*${SHMEM_PAGES})" | bc)"
	echo -en ">>> FINAL SHMEM: ${SHMEM}\n"
	echo "CONFIG_SHMEM_SIZE=\"${SHMEM}\"" >>${TARGET}${DODIR}/.config	|| return 1
	return 0
}

function release_kernel_initramfs {
	declare DODIR="${1}" && shift
	declare INITRAMFS_CONFIG=
	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_SOURCE=\"${CPIO_FILE/#${TARGET}}\"\n"
#>>>	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_ROOT_GID=0\n"
#>>>	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_ROOT_UID=0\n"
	if ${ROOTFS_CPIO}; then
		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION_NONE=y\n"
	else
		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION_XZ=y\n"
#>>>		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION=\".xz\"\n"
	fi
	${SED} -i \
		-e "/CONFIG_INITRAMFS_COMPRESSION/d" \
		-e "s|^.*(CONFIG_INITRAMFS_SOURCE)[^_].*$|${INITRAMFS_CONFIG}|g" \
		${TARGET}${DODIR}/.config			|| return 1
	${RM}	${TARGET}${DODIR}/usr/initramfs_data.cpio*	|| return 1
	return 0
}

function release_kernel_diff {
	declare DODIR="${1}" && shift
	if [[ -n ${TARGET} ]]; then
		${RSYNC_U} ${TARGET}${DODIR}/.config		${TARGET}${ARCDIR}/${KCFG}.initramfs	|| return 1
		${GREP} "CONFIG_(SHMEM|KERNEL|INITRAMFS|RD)_"	${TARGET}${ARCDIR}/${KCFG}.initramfs	|| return 1
		diff ${DIFF_OPTS} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${ARCDIR}/${KCFG}.initramfs	| ${GREP} "^[-+]"
	fi
	return 0
}

function release_kernel_build {
	declare DODIR="${1}" && shift
	declare KOUT="${1}" && shift
#>>>	declare BZIMAGE="${TARGET}${DODIR}/arch/x86_64/boot/bzImage"
	declare BZIMAGE="${TARGET}${DODIR}/arch/x86/boot/bzImage"
	declare BZ_MAKE="${TARGET}${DODIR}/arch/x86/Makefile"
	declare BZ_SEDR=".+ln -fsn.+/x86/boot/bzImage.+"
	if [[ -f ${BZ_MAKE}.${_TITLE} ]]; then ${MV}	${BZ_MAKE}{.${_TITLE},}	|| return 1; fi
	${SED} -i.${_TITLE} "s|^(${BZ_SEDR})$|\#\1|g"	${BZ_MAKE}		|| return 1
	safe_env make -C ${DODIR}			olddefconfig		|| return 1
	safe_env make -C ${DODIR}			bzImage			|| return 1
	${RSYNC_U} --copy-links ${BZIMAGE}		${KOUT}			|| return 1
	return 0
}

function _release_kernel {
	declare DODIR="${KDIR}"
	if [[ -z ${TARGET} ]]; then
		DODIR="${LDIR}"
	fi
	if [[ ! -f ${_RAMFS}.kernel ]]; then
		prepare_linux_directory		${DODIR}				|| return 1
		release_kernel_patch		${DODIR}				|| return 1
		release_kernel_config		${DODIR}				|| return 1
		release_kernel_shmem		${DODIR}				|| return 1
		release_kernel_initramfs	${DODIR}				|| return 1
		release_kernel_diff		${DODIR}				|| return 1
		release_kernel_build		${DODIR}	${_RAMFS}.kernel	|| return 1
	else
		common_exists ${FUNCNAME}						\
								${TARGET}${DODIR}	\
								${_RAMFS}.kernel	\
											|| return 1
	fi
	return 0
}

########################################

function _release_grub {
	FILE="${_RAMFS}.grub"
	if [[ ! -f ${FILE}.tar.xz ]] && [[ ! -f ${FILE}.zip ]]; then
		${RM}				${FILE}*		|| return 1
		${MKDIR}			${FILE}			|| return 1
		${HOME}/scripts/grub.sh		${FILE}			|| return 1
		${RM}				${FILE}/_*		|| return 1
		${RM}				${FILE}/*.tar		|| return 1
		${WGET_C} -P			${FILE} ${RUFUS_URL}	|| return 1
#>>>		common_tar			${FILE}			|| return 1
		7z d				${FILE}.zip		|| return 1
		7z a				${FILE}.zip ${FILE}	|| return 1
#>>>		${RM}				${FILE}			|| return 1
	else
		common_exists ${FUNCNAME}	${FILE}*		|| return 1
	fi
	return 0
}

########################################

function _release_report {
	echo -en "\n"
	${LL}						\
		${TARGET}/				\
		${_FINAL}*				\
							2>/dev/null
	echo -en "\n"
	${DU_L} --dereference --one-file-system		\
		${TARGET}${LDIR}/usr/initramfs_data.*	\
		${_RAMFS}*				\
							2>/dev/null
	return 0
}

########################################

#note: companion to the "prepare_symlinks" function
function _release_fetch {		#{main}
	declare FET_DST="${PWD}/${_TITLE}"
	declare FET_BAS="${_RAMFS/#${_FINAL}\/}"
	declare FET_SRC="${RSYNC_C} --copy-links --delete ${_FINAL}"
	declare FET_OUT=""
	if [[ ! -d ${_FINAL} ]]; then
		FET_SRC="${WGET_C} ${_SFDOWN}"
		FET_OUT="--directory-prefix"
	fi
	declare FET_PKG="${FET_DST}/${FET_BAS}.${PACKDIRS_LINK}.${FUNCNAME/#${MAKEIT}_}"
	${MKDIR}							${FET_DST}					|| return 1
	${FET_SRC}/${FET_BAS}.grub.zip ${FET_OUT}			${FET_DST}/					|| return 1
	7z e -aoa \
		-x\!\*/loopfile\* \
		-x\!\*/rufus\* \
		-o${FET_DST}/${_TITLE}.grub				${FET_DST}/${FET_BAS}.grub.zip			|| return 1
	${RM}								${FET_DST}/${_TITLE}.grub/${FET_BAS}.grub	|| return 1
	for FILE in kernel rootfs; do
		${FET_SRC}/${FET_BAS}.${FILE} ${FET_OUT}		${FET_DST}/					|| return 1
		${LN}			${FET_BAS}.${FILE}		${FET_DST}/${_TITLE}.${FILE}			||
			${RSYNC_C}	${FET_DST}/${FET_BAS}.${FILE}	${FET_DST}/${_TITLE}.${FILE}			|| return 1
		${FET_SRC}/${FET_BAS}.${FILE}.${_GPACK} ${FET_OUT}	${FET_DST}/					|| return 1
	done
	${FET_SRC}/${FET_BAS}.${_GREAD} ${FET_OUT}			${FET_DST}/					|| return 1
	if [[ ! -s ${FET_PKG} ]]; then
		cat /dev/null						>${FET_PKG}
	else
		shopt -s lastpipe
		variable_parse PACKDIRS | while read -r FILE; do
			${FET_SRC}/$(common_packdir ${FILE}) ${FET_OUT}	${FET_DST}/					|| return 1
		done
		shopt ${LASTPIPE} lastpipe
	fi
	(cd ${FET_DST};
		echo -en "\n"; ${LL}
		echo -en "\n"; ${DU_L} *
	)
	echo -en "\n"; ${LL} $(realpath --relative-to ${PWD} ${FET_PKG}); cat ${FET_PKG}
	return 0
}

########################################

#note: companion to the "prepare_packdirs" function
function _release_unpack {		#{main}
	declare UNPACK="${TARGET}${_GUNPK}"
	declare DOINST="${TARGET}${_GINST}/${_TITLE}"
	declare CREGEX+="([a-z]+[${PACKDIRS_CSEP}])?"
	declare FREGEX="(([[:space:]]+[(]).*([)]))?"
	declare PRINTF="%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s %s\n"
	declare SORTER="-k1.2"
	if [[ ! -f ${UNPACK} ]]; then
		shopt -s lastpipe
		variable_parse FSPACK ";" | while read -r FILE; do
			if ! variable_match FSKEEP FSARCH FSEXCL ";" "${FILE}"; then
				echo "${FILE}"							>>${UNPACK}		|| return 1
			fi
		done
		shopt ${LASTPIPE} lastpipe
	fi
	echo "# ${PACKDIRS_KEEP}<directory> = fetch/unpack directory, keep archive"		>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_INST}<directory> = fetch/unpack directory, remove archive"		>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_PACK}<directory> = remove directory, keep archive"			>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_GONE}<directory> = remove directory, remove archive"			>>${UNPACK}		|| return 1
	printf "${PRINTF}"												\
		"#${PACKDIRS_MARK} <none><directory> = ${PACKDIRS_DEFL}<directory>"					\
		"(<file>) = local archive"										\
												>>${UNPACK}		|| return 1
	shopt -s lastpipe
	variable_parse PACKDIRS "" "" "" true | while read -r FILE; do
		declare PFIL="${FILE/#*${PACKDIRS_CSEP}}"
		declare PSRC="$(common_packdir ${PFIL})"
		if variable_match FSEXCL ";" ${PFIL}; then
			echo -en ">>> EXCLUDING: ${PFIL}\n"
			continue
		fi
		if {
			[[ -z $(${GREP} "^${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_KEEP}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_INST}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_PACK}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_GONE}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]
		}; then
			if [[ -d ${TARGET}${PFIL} ]] && [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_KEEP}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ -d ${TARGET}${PFIL} ]] && [[ ! -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_INST}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ ! -d ${TARGET}${PFIL} ]] && [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_PACK}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ ! -d ${TARGET}${PFIL} ]] && [[ ! -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_GONE}${PFIL}"					>>${UNPACK}		|| return 1
			fi
		fi
		if [[ -n $(${GREP} "^${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_DEFL}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_KEEP}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_INST}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_INST}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_PACK}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_PACK}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_GONE}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_GONE}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		fi
		if [[ ! -f ${TARGET}${PFIL}.tar.xz ]] && {
			{ [[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]] && [[ ! -d ${TARGET}${PFIL} ]]; } ||
			[[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_PACK}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> FETCHING: ${PFIL}\n"
			if ! ${DOTEST}; then
				${MKDIR}							$(dirname ${PFIL})	|| return 1
				if [[ -f ${DOINST}/${PSRC} ]]; then
					${RSYNC_U} --copy-links ${DOINST}/${PSRC}		${TARGET}${PFIL}.tar.xz	|| return 1
				else
					${WGET_C} ${_SFDOWN}/${PSRC} -O				${TARGET}${PFIL}.tar.xz	|| return 1
				fi
			fi
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> UNPACKING: ${PFIL}"
			if ! ${DOTEST}; then
				echo -en " "
				if ! common_untar ${TARGET}${PFIL} 2>&1 | ${SED} "s|^.*$||g" | tr '\n' '.'; then
					return 1
				fi
			fi
			echo -en "\n"
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_PACK}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_GONE}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> REMOVING: ${PFIL}\n"
			if ! ${DOTEST}; then
				${RM} ${TARGET}${PFIL}									|| return 1
			fi
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_GONE}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> REMOVING: ${PFIL}.tar.xz\n"
			if ! ${DOTEST}; then
				${RM} ${TARGET}${PFIL}.tar.xz								|| return 1
			fi
		fi
		NEXT=""
		if [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
			NEXT="${PFIL}.tar.xz"
		elif [[ -f ${DOINST}/${PSRC} ]]; then
			NEXT="${DOINST/#${TARGET}}/${PSRC}"
		fi
		${SED} -i "s|^(.?${FILE})${FREGEX}$|\1\3${NEXT}\4|g"				${UNPACK}		|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	if {
		[[ ! -d ${TARGET}${KDIR} ]] &&
		[[ ! -L ${TARGET}${KDIR} ]];
	}; then
		echo -en ">>> LINKING: ${KDIR}\n"
		if ! ${DOTEST}; then
			${RM}									${TARGET}${KDIR}	|| return 1
			${LN} --relative ${TARGET}${LDIR}					${TARGET}${KDIR}	|| return 1
		fi
	fi
	if ! ${DOTEST}; then
		echo -en "\n"
		shopt -s lastpipe
		variable_parse FSUPDT ";" | while read -r FILE; do
			eval safe_env								${FILE}			|| return 1
		done
		shopt ${LASTPIPE} lastpipe
	fi
	echo -en "\n"; common_packdirs_list
	echo -en "\n"
	echo -en ">>> EDIT THE (${UNPACK}) FILE TO MODIFY THE LIST OF DIRECTORIES TO UNPACK <<<\n"
	echo -en ">>> ARCHIVES MUST EXIST OR BE IN THE (${DOINST}) DIRECTORY <<<\n"
	echo -en ">>> OTHERWISE NETWORK ACCESS WILL BE REQUIRED TO FETCH THEM <<<\n"
	echo -en "\n"
	cat ${UNPACK}
	return 0
}

########################################

#NOTE: CONSULT THE "SYSTEM INSTALLATION" TABLE IN "README" FOR THIS SECTION

#note: compare with the "${_CFG}" option in the "_system" script
#note: cross-reference with the "release_reset" function any time this changes
function release_install_root {
	eval ${RSYNC_U} \
		--one-file-system \
		--filter="-_/.${_TITLE}" \
		--filter="-_/_${_TITLE}" \
		$(variable_parse SKIPDIRS_GOS	"" "--filter=\"-_" "\"") \
		$(variable_parse DEVDIRS	"" "--filter=\"-_" "/*\"") \
		${TARGET}/* ${_GINST}/		|| return 1
#>>>		${TARGET}/ ${_GINST}		|| return 1
	${TARGET}${REALDEV} ${_GINST}/dev	|| return 1
	TARGET="${_GINST}" _release_reset	|| return 1
	TARGET="${_GINST}" _release_unpack	|| return 1
	return 0
}

function release_install_boot {
	declare DEVICE="$(findmnt --noheadings --output SOURCE --target ${_GINST}/boot)"
	mount-robust --dev				${_GINST}			|| return 1
	${RSYNC_U} /usr/lib/grub/i386-pc/		${_GINST}/boot/grub		|| return 1
	chroot ${_GINST} boot-update --verbose						|| return 1
	mount-robust -u --dev				${_GINST}			|| return 1
	${SED} -i \
		-e "s|([[:space:]])[/](kernel\|init)|\1/boot/\2|g" \
		-e "s|(real_root=)[^[:space:]]+|\1${DEVICE} root=${DEVICE}|g" \
							${_GINST}/boot/grub/grub.cfg	|| return 1
	${SED} -i \
		-e "s|^([^#].+)$|#\1|g" \
		-e "s|^(.+)([[:space:]][/][[:space:]])|${DEVICE}\2|g" \
							${_GINST}/etc/fstab		|| return 1
	return 0
}

function _release_install {		#{main}
	if [[ ! -d ${_GINST} ]]; then
		echo -en "\n"
		echo -en ">>> THIS OPTION REQUIRES THAT THE (${_GINST}) INSTALL DIRECTORY EXISTS <<<\n"
		echo -en "\n"
		return 1
	fi
	release_install_root	|| return 1
	release_install_boot	|| return 1
	${LL} ${_GINST}		|| return 1
	return 0
}

################################################################################

function _publish_release {		#{main} #{reset}
	declare RESET= ; if [[ ${1} == ${_RST} ]]; then RESET="${_RST}" && shift; elif ${DOREDO}; then RESET="${_RST}"; fi
	if [[ -n ${RESET} ]]; then
		shift
		DOREDO="false" _publish_prep	|| return 1
	fi
	DOREDO="false" _publish_gitdir		|| return 1
	DOREDO="false" _publish_export		|| return 1
	DOREDO="false" _publish_direct		|| return 1
	DOREDO="false" _publish_upload		|| return 1
	DOREDO="false" _publish_report		|| return 1
	return 0
}

########################################

function _publish_prep {
	variable_parse DEVDIRS "" "" "/"	>${TARGET}/.gitignore			|| return 1
	sort -u -o ${TARGET}/.gitignore		${TARGET}/.gitignore			|| return 1
	${SED} -i "/^$/d"			${TARGET}/.gitignore			|| return 1
	${RM}					${CPIO_FILE}				|| return 1
	${RM}					${CPIO_FILE}.dir			|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}		|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}.dir		|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}.exclude	|| return 1
	${RM}					${ROOTFS_FILE}.dir			|| return 1
	${RM}					${ROOTFS_FILE}.exclude			|| return 1
	${RM}					${_RAMFS}.grub				|| return 1
	${RM}					${TARGET}/tmp/.ccache			|| return 1
	return 0
}

########################################

function _publish_gitdir {
#>>>	if [[ -x $(which task 2>/dev/null) ]]; then
#>>>		FILE="${GIT} --git-dir=${_DOCDIR}.git --work-tree=${_DOCDIR}"
#>>>		NEXT="Automated \"TODO.md\" update."
#>>>		task zoom	project:geek.gary-os >${_DOCDIR}/TODO.md	|| return 1
#>>>		${FILE} add	TODO.md						|| return 1
#>>>		${FILE} commit	--message="${NEXT}" TODO.md			|| return 1
#>>>	fi
	function git-export-preprocess {
		${SED} -i "s%^(From[:][ ]).+%\1${_AUTHOR}%g"							"${@}"	|| return 1
		${SED} -i "N;N;s%^(Subject[:][ ])[[]git-backup[^[]+[[](.+)[]]%\1(RELEASE:\2)%g"			"${@}"	|| return 1
		${SED} -i "N;N;s%^(From 444e47c253085ed084c4069e53505113b39619da.+Date[:][ ].+)-0800%\1+0000%g"	"${@}"	|| return 1
		return 0
	}
	function git-export-postprocess {
		NEXT="0"
		for FILE in $(
			git-list --reverse | ${GREP} "RELEASE" | ${GREP} -o "[a-z0-9]{40}[ ]"
		); do
			${GIT} tag --force ${RELEASE[${NEXT}]} ${FILE}	|| return 1
			NEXT="$((${NEXT}+1))"				|| return 1
		done
		return 0
	}
	declare DOC_FILES=
	declare SAVE_FILES=
	SAVE_FILES+="${CMTFIL}"
	SAVE_FILES+="^_commit"
	SAVE_FILES+="^_config\*"
	SAVE_FILES+="^${_GPACK}"
	SAVE_FILES+="^_packages\*"
	declare SETUP_FILES=
	SETUP_FILES+="gentoo"
	SETUP_FILES+="^linux"
	declare STATIC_FILES=
	STATIC_FILES+=".bashrc"
	STATIC_FILES+="^.vimrc"
	STATIC_FILES+="^scripts/grub.sh"
	STATIC_FILES+="^scripts/metro.sh"
	STATIC_FILES+="^scripts/qemu.bsh"
	STATIC_FILES+="^scripts/qemu-network\*"
	eval git-export ${_TITLE} ${_RELDIR} ${_GITHUB}					\
		+git-export-preprocess +git-export-postprocess				\
		${_TITLE}:${_DOCDIR}:${DOC_FILES}					\
		_${_TITLE}:${_SAVDIR}:${SAVE_FILES}					\
		setup:/.g/_data/zactive/.setup:${SETUP_FILES}				\
		static:/.g/_data/zactive/.static:${STATIC_FILES}			\
											|| return 1
	FILE="git --git-dir=/home/git/p/${_TITLE}/code.git config"
	NEXT=
	NEXT+="${FILE} --unset receive.denynonfastforwards;"
	NEXT+="${FILE} --list;"
	NEXT+="exit 0;"
	echo -en "${NEXT}\n" | ssh ${_SFRSSH}						|| return 1
	${GIT} --git-dir=${_RELDIR}/.${_TITLE}.git --work-tree=${_RELDIR}/.${_TITLE}	\
		push --mirror ${_SFCODE}						|| return 1
	return 0
}

########################################

declare FILELIST="
	.${_TITLE}-
	${_TITLE}-
	portage-
	stage3-
"

function publish_export_filelist {
	FILE="${1}" && shift
	${LS} -d $(
		for NEXT in ${FILELIST}; do
			echo -en " ${FILE}/${NEXT}*"
		done
	) 2>/dev/null \
		|| return 1
	return 0
}

function publish_export_gitbackup {
	declare GDIR="${1}" && shift
	declare HASH="${1}" && shift
	FILE="$(
		for NEXT in ${FILELIST}; do
			(set -o pipefail;
				$(which git) --git-dir=${GDIR}.git --work-tree=${GDIR}	\
				ls-tree ${HASH}						\
					2>/dev/null					\
					| awk '{print $4;}'				\
					| ${GREP} "^${NEXT}"				\
			)								2>/dev/null
		done
	)"
	if [[ -n ${FILE} ]]; then
		(cd ${_OUTDIR} && git-backup -r ${HASH} ${FILE})			|| return 1
	fi
	FILE="$(realpath --canonicalize-missing --relative-to ${GDIR} $(
		find ${GDIR}/.${_TITLE}-*/ ${GDIR}/${_TITLE}-*/ -mindepth 1 -maxdepth 1	2>/dev/null
	) 2>/dev/null)"
	if [[ -n ${FILE} ]]; then
		(cd ${_OUTDIR} && git-backup -r ${HASH} ${FILE})			|| return 1
	fi
	return 0
}

function publish_export_underscore {
	FILE="${1}" && shift
	${RSYNC_U} --copy-links \
		${_OUTDIR}/.${_TITLE}-*/_$(basename ${FILE})/ \
		${_OUTDIR}/_$(basename ${FILE}) \
		|| return 1
	${RM} $(realpath --canonicalize-missing \
		${_OUTDIR}/.${_TITLE}-*/_$(basename ${FILE})
	)
	return 0
}

function publish_export_checksum {
	for FILE in "${@}"; do
		declare CHECKDIR="$(dirname ${FILE})"
		declare CHECKFIL="$(basename ${FILE})"
		declare CHECKSUM="${FILE}.hash.txt"
		if [[ -f ${CHECKDIR}/${CHECKFIL} ]]; then
			(set -o pipefail;
				(cd ${CHECKDIR}					&&
					sha256sum --tag		${CHECKFIL}	&&
					md5sum --tag		${CHECKFIL}	&& true
				) 2>&1 | tee			${CHECKSUM}	&& true
			)							|| return 1
			touch -r ${CHECKDIR}/${CHECKFIL}	${CHECKSUM}	|| return 1
		fi
	done
	return 0
}

function _publish_export {
	${MKDIR} ${_OUTDIR}									|| return 1
	${RM} ${_OUTDIR}.git									|| return 1
	${LN} ${_SAVDIR}.git ${_OUTDIR}.git							|| return 1
	declare INDEX=
	for INDEX in $(
		eval echo -en "{0..$((${#RELEASE[*]}-1))}"
	); do
		if [[ -n ${RELEASE[${INDEX}]} ]] && [[ -n ${CMTHASH[${INDEX}]} ]]; then
			echo -en "\n[ ${RELEASE[${INDEX}]} :: ${CMTHASH[${INDEX}]} ]\n"
		else
			continue
		fi
		publish_export_gitbackup ${_OUTDIR} ${CMTHASH[${INDEX}]}			|| return 1
		if [[ -d $(${LS} -d ${_OUTDIR}/.${_TITLE}-* 2>/dev/null) ]]; then
			if [[ ${RELEASE[${INDEX}]} == ${RELEASE[-1]} ]]; then
				publish_export_underscore ${DSTDIR}				|| return 1
				publish_export_underscore ${PAKDIR}				|| return 1
			fi
			${RSYNC_U} --copy-links							\
				$(publish_export_filelist ${_OUTDIR}/.${_TITLE}-*)		\
				${_OUTDIR}/							|| return 1
			${RM} $(realpath --canonicalize-missing $(
				publish_export_filelist ${_OUTDIR}/.${_TITLE}-*
			))									|| return 1
			until [[ -z $(find ${_OUTDIR} -type d -empty) ]]; do
				${RM} $(find ${_OUTDIR} -type d -empty)				|| return 1
			done
			${RM} ${_OUTDIR}/.${_TITLE}-*						|| return 1
		fi
		(cd ${_OUTDIR} && publish_export_checksum $(publish_export_filelist .))		|| return 1
		${MKDIR} ${_OUTDIR}/${RELEASE[${INDEX}]}					|| return 1
		${RSYNC_U} --copy-links								\
			$(publish_export_filelist ${_OUTDIR})					\
			${_OUTDIR}/${RELEASE[${INDEX}]}/					|| return 1
		${RM} $(publish_export_filelist ${_OUTDIR})					|| return 1
		touch -r $(
			${LS} -t ${_OUTDIR}/${RELEASE[${INDEX}]}/*.kernel 2>/dev/null		|
			head -n1
		) ${_OUTDIR}/${RELEASE[${INDEX}]}						|| return 1
	done
	${RM} ${_OUTDIR}.git									|| return 1
	${RM} ${_OUTDIR}/+index*								|| return 1
	${GIT} --git-dir=${_SAVDIR}.git --work-tree=${_SAVDIR} reset				|| return 1
	for INDEX in ${RELEASE[*]}; do
		for NEXT in $(
			${LS} ${_OUTDIR}/${INDEX}/*.{kernel,initrd} 2>/dev/null
		); do
			declare OUTFILE="$(
				echo -en "$(basename ${NEXT})" |
				${SED} \
					-e "s%^stage3%${_TITLE}%g" \
					-e "s%[a-z0-9]{40}[.][0-9][.]tar[.]xz%${INDEX}%g"
			)"									|| return 1
			${RSYNC_U} ${NEXT} ${_OUTDIR}/${OUTFILE}				|| return 1
			publish_export_checksum ${_OUTDIR}/${OUTFILE}				|| return 1
		done
	done
	return 0
}

########################################

function _publish_direct {
	if [[ -L ${_OUTDIR}/${_VERSN} ]]; then
		cat ${TARGET}/etc/motd	>${_EAMARK}
		${LL}			${_EAMARK}
	fi
	for FILE in \
		README.md \
		LICENSE.md \
	; do
		${RSYNC_U} --copy-links	${_G_REPO}/${FILE} ${_OUTDIR}/	|| return 1
	done
	declare ROOTFS_DIRECT="${_OUTDIR}/$(basename ${_ROOTFS})"
	if { {
		[[ -f ${_ROOTFS} ]];
	} && {
		[[ ! -f ${ROOTFS_DIRECT}.hash.txt ]] ||
		[[ -n $(find -L ${_ROOTFS} -newer ${ROOTFS_DIRECT}.hash.txt) ]];
	} }; then
		${LN} --relative	${_ROOTFS}* ${_OUTDIR}/		|| return 1
		publish_export_checksum	${ROOTFS_DIRECT}		|| return 1
	fi
	return 0
}

########################################

function _publish_upload {
	find			${_OUTDIR} -type d -exec chmod 755 {} \;	|| return 1
	find			${_OUTDIR} -type f -exec chmod 644 {} \;	|| return 1
	chown -R root:root	${_OUTDIR}					|| return 1
	eval ${RSYNC_U} --copy-links --delete-excluded				\
		$(for FILE in $(${LS} --directory ${_OUTDIR}/${_VERSN}/*/); do
			echo "--filter=\"-_/${_VERSN}/$(basename ${FILE})\""
		done)		${_OUTDIR}/ ${_SFFILE}				|| return 1
	return 0
}

########################################

function _publish_report {
	(cd ${_OUTDIR};
		echo -en "\n"; ${LL} --dereference v[0-9]*
		echo -en "\n"; ${LL} --dereference
		echo -en "\n"; ${LL} $(find ./ -type l | ${SED} "s|^[.][/]||g")
	)
	return 0
}

#>>> exit 0
################################################################################
# end of file
################################################################################
