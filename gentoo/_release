#!/usr/bin/env bash
#>>> source ${HOME}/.bashrc
################################################################################

if { [[ -z ${_SYSTEMED} ]] || ! ${_SYSTEMED}; }; then
	echo -en "\n"
	echo -en ">>> THIS SCRIPT IS NOT MEANT TO BE RUN DIRECTLY <<<\n"
	echo -en ">>> PLEASE USE THE (_system -v) SCRIPT INSTEAD <<<\n"
	echo -en "\n"
	exit 1
fi

################################################################################

#NOTE: SCRIPT NAME AND FUNCTION NAMES (${PREPIT}, ${MAKEIT}, ${SHIPIT}) MUST MATCH FOR "_SYSTEM" WRAPPING TO WORK
#NOTE: UPDATE "#SETTINGS" LINES IN "_SYSTEM" SCRIPT WHEN THESE VARIABLES CHANGE

export _GNAME="GaryOS"
export _TITLE="gary-os"
export _VERSN="v5.0"
export _RDATE="$(date --iso=date)"

export _FINAL="${TARGET}/.${_TITLE}-${ESUB}"
export _RAMFS="${_FINAL}/${_TITLE}-${_VERSN}-${ESUB}"

export _GOVLY="/.overlay"
export _GUNPK="/.unpack"
export _GINST="/.install"

export _GREAD="readme.md"
export _GPACK="packages.txt"

########################################

#>>> #{isexit} + ${target} = /\t\treturn 0
#>>> pass-through =
#>>>	/DOREDO="${DOREDO}"
#>>>	/DOFAST="${DOFAST}"
#>>>	/DOTEST="${DOTEST}"

#>>> if [[ -z ${TARGET} ]]; then
#>>> 	_TITLE="${_TITLE}-custom"
#>>> fi

########################################

declare _AUTHOR="Gary B. Genett <me@garybgenett.net>"
declare _LOGIN="garybgenett"

declare _GITHUB="ssh://git@github.com/${_LOGIN}/${_TITLE}.git"
declare _SFCODE="ssh://${_LOGIN}@git.code.sf.net/p/${_TITLE}/code"
declare _SFFILE="${_LOGIN}@web.sourceforge.net:/home/frs/project/${_TITLE}"
declare _SFRSSH="${_LOGIN},${_TITLE}@shell.sourceforge.net create"
declare _SFDOWN="https://sourceforge.net/projects/gary-os/files/${_VERSN}"

declare _DOCDIR="/.g/_data/zactive/coding/${_TITLE}"
declare _BLDDIR="/.g/_data/_builds"
declare _SAVDIR="${_BLDDIR}/_${_TITLE}"
declare _ROOTFS="${_BLDDIR}/_${_TITLE}.rootfs"
declare _RELDIR="${_BLDDIR}/.${_TITLE}"
declare _G_REPO="${_RELDIR}/.${_TITLE}"
declare _OUTDIR="${_RELDIR}.release"

declare _EAMARK="${_FINAL}/_EARLY_ACCESS_DIRECTORY--IN_DEVELOPMENT--UNSUPPORTED"

declare -a RELEASE=
declare -a CMTHASH=
RELEASE[0]="v0.1"; CMTHASH[0]="4d1b46b02798a1d3d3421b1c8087d80a80012a53"
RELEASE[1]="v0.2"; CMTHASH[1]="99c1bafbf1116c1400705803da45e1ac03f3d492"
RELEASE[2]="v0.3"; CMTHASH[2]="6e968d212ea62a1054e3cafa2436b6a98cf8776b"
RELEASE[3]="v1.0"; CMTHASH[3]="f6885f3482b95fe15a688135c441f8f6391c9529"
RELEASE[4]="v1.1"; CMTHASH[4]="9b653e64164e68873333043b41f8bbf23b0fbd55"
RELEASE[5]="v2.0"; CMTHASH[5]="deda452a0aab311f243311b48a39b7ac60ab3fd8"
RELEASE[6]="v3.0"; CMTHASH[6]="35141e1e20259d7d1c2f4b143c6ae4505d7d5045"
RELEASE[7]="v4.0"; CMTHASH[7]="428ed8058597a3530ec2d0207dda6ffed6082c0f"
RELEASE[8]="v5.x"; CMTHASH[8]="c769c14a73b53c741ef95ff21b88d752c18e474e"
RELEASE[9]="v5.0"; CMTHASH[9]="198fea2f4636949dad11ae710192e3fdb59ec446"

declare -a RELEASE_SKIP=(8)

########################################

declare CMTFIL="_commit"
declare COMMIT=
for FILE in \
	${_TITLE} \
	.setup \
	.static \
; do
	NEXT="$(cat /.g/_data/zactive{,/coding}/${FILE}.git/refs/heads/master 2>/dev/null)"
	if [[ -n "${NEXT}" ]]; then
		COMMIT="${COMMIT}${FILE}: ${NEXT}\n"
	fi
done

################################################################################

declare LASTPIPE="$(shopt lastpipe | ${SED} "s%^.+(on|off)$%\1%g")"
if [[ ${LASTPIPE} == on ]]; then
	LASTPIPE="-s"
else
	LASTPIPE="-u"
fi

########################################

function variable_parse {
	declare VARIABLE="${1}"		&& shift
	declare V_SPACER="${1:- }"	&& shift
	declare V_PREFIX="${1}"		&& shift
	declare V_SUFFIX="${1}"		&& shift
	declare V_CATGRY="${1:-false}"	&& shift
	declare V_SELECT=
	declare V_LOOPER=
	for V_SELECT in ${VARIABLE}; do
		echo "${!V_SELECT}" | ${SED} "s|${V_SPACER}|\n|g" | while read -r V_LOOPER; do
			if [[ -n ${V_LOOPER} ]]; then
				if ! ${V_CATGRY}; then
					V_LOOPER="$(echo "${V_LOOPER}" | ${SED} "s|^[^${PACKDIRS_CSEP}]+[${PACKDIRS_CSEP}]||g")"
				fi
				echo "${V_PREFIX}${V_LOOPER}${V_SUFFIX}"
			fi
		done
	done
	return 0
}

########################################

function variable_match {
	declare MARIABLE="${1}"		&& shift
	declare M_SPACER="${1:- }"	&& shift
	declare M_EQUALS="${1}"		&& shift
	declare M_SUBDIR="${1:-false}"	&& shift
	declare M_SELECT=
	declare M_LOOPER=
	shopt -s lastpipe
	for M_SELECT in ${MARIABLE}; do
		variable_parse ${M_SELECT} "${M_SPACER}" | while read -r M_LOOPER; do
			if {
				{ ! ${M_SUBDIR} && [[ "${M_EQUALS}" == "${M_LOOPER}" ]]			; } ||
				{ ${M_SUBDIR} && [[ ${M_EQUALS} != ${M_EQUALS/#${M_LOOPER}\/} ]]	; };
			}; then
				shopt ${LASTPIPE} lastpipe
				return 0
			fi
		done
	done
	shopt ${LASTPIPE} lastpipe
	return 1
}

################################################################################

declare RUFUS_URL="https://github.com/pbatard/rufus/releases/download/v3.14/rufus-3.14.exe"

########################################

declare SHMEM_MEM="$(((2**20)*768))"

########################################

declare DU_L="${DU} --summarize --total --block-size 1M"
declare DU_S="${DU} --summarize --apparent-size --block-size 1"

########################################

declare CPIO_FILE="${_RAMFS}.cpio"

#note: this is an environment variable for "xz" and is not explicitly used in this script
#note: this is not for direct "xz" commands, but for "tar --xz" archiving
export XZ_OPT="--verbose --threads=0 --extreme -9"

declare XARGS="xargs --max-procs 0 --max-args 1 --null	--arg-file ${CPIO_FILE}.nul"
declare CPIO_IN="cpio -v --create --format newc --null	--file ${CPIO_FILE}	--directory" #>>> ${TARGET}
declare CPIO_OUT="cpio -v --extract			--file ${CPIO_FILE}	--directory" #>>> ${CPIO_FILE}.dir
declare XZ="xz -vv --compress --stdout --format xz --check crc32"

########################################

declare PATCH="patch --force --strip=1"
declare PATCH_DIR="${ARTDIR}/patches"
declare -a PATCHES
PATCHES[0]="shmem-add-shmem_size-option-set-filesystem-size.v5.4-rc2.v5.6_updated.patch"

########################################

declare PACKDIRS_LINK="packdir"
declare PACKDIRS_DSEP="--"
declare PACKDIRS_CSEP=":"
declare PACKDIRS_PRNT="50"

#>>> for CHAR in {32..47} {58..64} {91..96} {123..126}; do printf "%3s" "${CHAR}"; printf " [\\$(printf "%0.3o" "${CHAR}")]\n"; done
#note: these must not be "[a-z]" and category names must be "[a-z]+[:]" for regular expressions to work properly
declare PACKDIRS_KEEP="*"
declare PACKDIRS_INST="+"
declare PACKDIRS_PACK="-"
declare PACKDIRS_GONE="|"
declare PACKDIRS_MARK="-"

declare PACKDIRS_DEFL="${PACKDIRS_INST}"

FSUPDT="
rc-service udev restart || true
rc-service modules restart || true
rc-service keymaps restart || true
${FSUPDT}
"
FSUPDT="$(echo "${FSUPDT}" | tr '\n' ';' | ${SED} -e "s|^;+||g" -e "s|;+$||g" -e "s|;| ; |g")"

#note: the "$repdir" and "$ldir" directories are packed in the "prepare_repdir" and "prepare_linux" functions, respectively
#note: adding them here ensures they will be handled properly by functions like "release_reset" and "release_unpack", as though they were regular archives
#note: the "$ldir-*" directories are handled in "$skipdirs" below
for FILE in ${MDIR} ${FDIR}		; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSPACK+="; ${_TITLE}:${FILE}"; fi; done
for FILE in ${REPDIR} ${LDIR} ${PDBDIR}	; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSKEEP+="; ${_TITLE}:${FILE}"; fi; done
for FILE in ${REPDIR}.git		; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSARCH+="; ${_TITLE}:${FILE}"; fi; done
for FILE in $((
		find ${TARGET}/boot/{System.map,initramfs,kernel}-*
		find ${TARGET}/etc/kernels	-mindepth 1 -maxdepth 1
		find ${TARGET}${MDIR}		-mindepth 1 -maxdepth 1
	) 2>/dev/null |
		${GREP} -v "${KVER}-gentoo$" |
		${SED} "s|^${TARGET}||g" |
		sort
	)				; do if ! variable_match "FSPACK FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then FSEXCL+="; ${_TITLE}:${FILE}"; fi; done
if ! ${DOTEST}; then
	FSPACK="$(variable_parse FSPACK ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|^;+||g" -e "s|;+$||g" -e "s|;| ; |g")"
	FSKEEP="$(variable_parse FSKEEP ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|^;+||g" -e "s|;+$||g" -e "s|;| ; |g")"
	FSARCH="$(variable_parse FSARCH ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|^;+||g" -e "s|;+$||g" -e "s|;| ; |g")"
	FSEXCL="$(variable_parse FSEXCL ";" "" "" true | sort -u | tr '\n' ';' | ${SED} -e "s|^;+||g" -e "s|;+$||g" -e "s|;| ; |g")"
fi

declare PACKDIRS="
$(variable_parse FSPACK ";" "" "" true)
$(variable_parse FSKEEP ";" "" "" true)
$(variable_parse FSARCH ";" "" "" true)
"
declare PACKDIRS_LIST="
${PACKDIRS}
$(variable_parse FSEXCL ";" "" "" true)
"
if ! ${DOTEST}; then
	PACKDIRS="$(variable_parse PACKDIRS "" "" "" true | sort -u)"
fi

declare PACKDIRS_SKIP="
	${LDIR}\*/kernel/kheaders_data.tar.xz
	/usr/share/calibre/hyphenation/dictionaries.tar.xz
"

########################################

declare ROOTFS_NAME="rootfs"
declare ROOTFS_FILE="${_RAMFS}.${ROOTFS_NAME}"

declare ROOTFS_CUST="false"
declare ROOTFS_TYPE="squashfs"
declare ROOTFS_COMP="-comp xz -b $((2**20)) -Xdict-size 100%"
declare ROOTFS_OPTS="-noappend -info -xattrs ${ROOTFS_COMP} -wildcards -ef" #>>> ${ROOTFS_FILE}.exclude"

declare ROOTFS_ROOT="/.${_TITLE}.${ROOTFS_NAME}"
declare ROOTFS_ROOT_SRC="${ROOTFS_ROOT/#\/\./\/${_TITLE}\/}"
declare ROOTFS_ROOT_OPT="groot"
declare ROOTFS_FUNC="rescue"

declare ROOTFS_LDD="${TARGET:+chroot ${TARGET} }ldd"
declare ROOTFS_BUSYBOX="/bin/busybox"
declare ROOTFS_COREUTILS="/usr/bin/coreutils"
declare ROOTFS_BASH="/bin/bash"
declare ROOTFS_SHELL="/bin/sh"
#>>>if [[ -n $(${ROOTFS_LDD} ${ROOTFS_BASH} 2>/dev/null | ${GREP} "not a dynamic executable") ]]; then
#>>>	ROOTFS_SHELL="${ROOTFS_BASH}"
#>>>fi

#note: update the "#{rootfs}" markers in "sets/gary-os" whenever "$rootfs_utils" changes
#note: verify accuracy using "${dotest}" in the "release_rootfs_cpio" function
declare ROOTFS_UTILS="
${ROOTFS_BASH}
\
/bin/grep
/bin/sed
/bin/tar
/usr/bin/make
/usr/bin/rsync
/usr/bin/tftp
\
/bin/mount
/bin/umount
/sbin/fsck
/sbin/fsck.ext2
/sbin/fsck.ext3
/sbin/fsck.ext4
/sbin/mount.fuse
/usr/sbin/fsck.exfat
/usr/sbin/fsck.fat
/usr/sbin/fsck.vfat
/usr/sbin/mount.exfat
/usr/sbin/mount.exfat-fuse
/usr/sbin/mount.ntfs
/usr/sbin/mount.ntfs-3g
"

declare ROOTFS_FILES="
/.profile
/etc/inittab
/initrc
"
declare ROOTFS_FILE_VARS="
_GNAME
_TITLE
_VERSN
_RDATE
_GOVLY
_GUNPK
_GPACK
FUNTOO
FUNDAT
KVER
\
DOTEST
ROOTFS_NAME
ROOTFS_TYPE
ROOTFS_ROOT
ROOTFS_ROOT_SRC
ROOTFS_ROOT_OPT
ROOTFS_FUNC
ROOTFS_BASH
ROOTFS_SHELL
"

########################################

function realdev {
	#note: ported over directly from: https://github.com/garybgenett/runit/blob/master/runit/1
	FILE="${1}" && shift
	[ ! -d ${FILE}/pts     ] && mkdir -m 0755 ${FILE}/pts
	[ ! -d ${FILE}/shm     ] && mkdir -m 0755 ${FILE}/shm
	[ ! -c ${FILE}/console ] && mknod -m 0600 ${FILE}/console	c 5  1
	[ ! -c ${FILE}/kmsg    ] && mknod -m 0666 ${FILE}/kmsg		c 1  11
	[ ! -c ${FILE}/null    ] && mknod -m 0666 ${FILE}/null		c 1  3
	[ ! -c ${FILE}/random  ] && mknod -m 0666 ${FILE}/random	c 1  8
	[ ! -c ${FILE}/rtc     ] && mknod -m 0600 ${FILE}/rtc		c 10 135
	[ ! -c ${FILE}/tty0    ] && mknod -m 0600 ${FILE}/tty0		c 4  0
	[ ! -c ${FILE}/urandom ] && mknod -m 0666 ${FILE}/urandom	c 1  9
	[ ! -c ${FILE}/zero    ] && mknod -m 0666 ${FILE}/zero		c 1  5
	[ ! -L ${FILE}/core    ] && ln -fns /proc/kcore			${FILE}/core
	[ ! -L ${FILE}/fd      ] && ln -fns /proc/self/fd		${FILE}/fd
	[ ! -L ${FILE}/stderr  ] && ln -fns /proc/self/fd/2		${FILE}/stderr
	[ ! -L ${FILE}/stdin   ] && ln -fns /proc/self/fd/0		${FILE}/stdin
	[ ! -L ${FILE}/stdout  ] && ln -fns /proc/self/fd/1		${FILE}/stdout
	return 0
}

declare DEVDIRS="
/dev
/mnt
/proc
/run
/sys
\
/tmp
/var/cache
/var/lock
/var/log
/var/run
/var/tmp
"

declare SKIPDIRS_GOS="
/.gitignore
/${CMTFIL}
\
/${_FINAL/#${TARGET}\/}
/${_RAMFS/#${TARGET}\/}*
\
${_GOVLY}
${_GUNPK}
${_GINST}
\
${ARCDIR}*
${GENDIR}*
"
declare SKIPDIRS_FUN="
${DSTDIR}
${PAKDIR}
\
${LDIR}-*
"
declare SKIPDIRS="
$(variable_parse SKIPDIRS_GOS)
${PACKDIRS_MARK}
$(variable_parse SKIPDIRS_FUN)
${PACKDIRS_MARK}
$(variable_parse PACKDIRS)
${PACKDIRS_MARK}
$(variable_parse FSARCH ";" "" ".tar.xz")
${PACKDIRS_MARK}
$(variable_parse FSEXCL ";")
$(variable_parse FSEXCL ";" "" ".tar.xz")
${PACKDIRS_MARK}
$(variable_parse DEVDIRS "" "" "/.*")
$(variable_parse DEVDIRS "" "" "/*")
"
if ! ${DOTEST}; then
	SKIPDIRS="$(variable_parse SKIPDIRS | ${SED} "/^${PACKDIRS_MARK}$/d" | sort -u)"
fi

################################################################################

function common_exists {
	declare SRC_FUNC="${1}" && shift
	echo -en "\n"
	echo -en ">>> THE OUTPUT FILES OF (${SRC_FUNC}) SEEM TO ALREADY EXIST <<<\n"
	echo -en ">>> OR THE REQUIRED DIRECTORIES OR FILES ARE MISSING <<<\n"
	echo -en "\n"
	${LL} --directory "${@}"
	echo -en "\n"
	return 0
}

########################################

function common_tar {
	declare SRC_FILE="${1}" && shift
	if [[ ! -f ${SRC_FILE}.tar.xz ]] && [[ -d ${SRC_FILE} ]] && [[ ! -L ${SRC_FILE} ]]; then
		tar -cvv --xz				\
			-C $(dirname ${SRC_FILE})	\
			-f ${SRC_FILE}.tar.xz		\
			${@}				\
			$(basename ${SRC_FILE})		|| return 1
	else
		common_exists ${FUNCNAME}		\
			${SRC_FILE}.tar.xz ${SRC_FILE}	|| return 1
	fi
	return 0
}

########################################

function common_untar {
	declare SRC_FILE="${1}" && shift
	if [[ -f ${SRC_FILE}.tar.xz ]] && [[ ! -d ${SRC_FILE} ]] && [[ ! -L ${SRC_FILE} ]]; then
		FILE="$(dirname ${SRC_FILE})"
		${MKDIR} ${FILE}			|| return 1
		tar -vvx --xz				\
			-C ${FILE}			\
			-f ${SRC_FILE}.tar.xz		\
			${@}				|| return 1
	else
		common_exists ${FUNCNAME}		\
			${SRC_FILE}.tar.xz ${SRC_FILE}	|| return 1
	fi
	return 0
}

########################################

function common_packdir {
	declare SRC_FILE="${1}" && shift
	echo "${_RAMFS/#${_FINAL}\/}.${PACKDIRS_LINK}${SRC_FILE//\//${PACKDIRS_DSEP}}.tar.xz"
	return 0
}

########################################

function common_packdirs_list {
	${LL} --directory $(
		variable_parse PACKDIRS_LIST "" "${TARGET}"				| sort -u
		variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz"			| sort -u
	)												2>/dev/null
	echo -en "\n"; ${DU_L} $(variable_parse PACKDIRS_LIST "" "${TARGET}"		| sort -u)	2>/dev/null
	echo -en "\n"; ${DU_L} $(variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz"	| sort -u)	2>/dev/null
	return 0
}

################################################################################

#NOTE: CONSULT THE "SYSTEM INSTALLATION" TABLE IN "README" FOR THIS SECTION

#note: this is called statically in the "_system" script, under the "$_cfg" option
#note: cross-reference with the "release_install" function any time this changes
function _release_reset {		#{ismain}
	${RM} ${TARGET}/.gitignore			|| return 1
	${RM} ${TARGET}/${CMTFIL}			|| return 1
	${RM} ${TARGET}/.${_GPACK/%.txt}*		|| return 1
	if [[ -n ${TARGET} ]]; then
		${RM} ${TARGET}/.${_TITLE}*		|| return 1
		${RM} ${TARGET}/_${_TITLE}*		|| return 1
	fi
	#note: checking if the output directory is a mounted filesystem or symlink
	#note: this is created in the "release_unpack" function
	FILE="$(findmnt --noheadings --output TARGET --target ${_FINAL})"
	if [[ ${FILE} != ${_FINAL} ]] && [[ ! -L ${_FINAL} ]]; then
		${RM} ${_FINAL}				|| return 1
	else
		${RM} ${_EAMARK}			|| return 1
		${RM} ${_FINAL}/stage3-*		|| return 1
		${RM} ${_FINAL}/_$(basename ${DSTDIR})	|| return 1
		${RM} ${_FINAL}/_$(basename ${PAKDIR})	|| return 1
		${RM} ${_RAMFS}*			|| return 1
	fi
	#note: all "prepare_*" functions that "#{isexit}" on "${doredo}"
	DOREDO="true" _prepare_config			|| return 1
	DOREDO="true" _prepare_packdirs			|| return 1
	DOREDO="true" _prepare_symlinks			|| return 1
	${RM}		${TARGET}${LDIR}		|| return 1
	${LN} ${KBAS}	${TARGET}${LDIR}		|| return 1
	return 0
}

########################################

function _release_review {		#{ismain}
	variable_parse SKIPDIRS
	sleep 10
	#note: initial rootfs size with "$fspack" and "$fskeep" still packed (kernel size)
	#note: counting them in reverse, so that embedded packdirs get excluded
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSPACK ";" "${FILE}" true ||
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSPACK ";" "${FILE}" true ||
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: loaded rootfs size with "$fspack" unpacked and "$fskeep" still packed (memory size)
	#note: counting them in reverse, so that embedded packdirs get excluded
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				if {
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				fi
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
				if {
					variable_match FSKEEP ";" "${FILE}" true;
				}; then
					echo "--exclude=\"${TARGET}${FILE}\""
				fi
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: final rootfs size with both "$fspack" and "$fskeep" unpacked (maximum memory size)
	#note: counting them in reverse, so that embedded packdirs get excluded
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match FSEXCL ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSARCH ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}\""
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSKEEP ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			elif variable_match FSPACK ";" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	#note: total filesystem size with all directories unpacked (completely loaded memory size)
	eval ncdu -r -x $(
		variable_parse SKIPDIRS | while read -r FILE; do
			if variable_match PACKDIRS "" "${FILE}"; then
				echo "--exclude=\"${TARGET}${FILE}.tar.xz\""
			else
				echo "--exclude=\"${TARGET}${FILE}\""
			fi
		done
	)	${TARGET}							|| return 1
	echo -en "\n[FSPACK]\n"; variable_parse FSPACK ";" | sort -u
	echo -en "\n[FSKEEP]\n"; variable_parse FSKEEP ";" | sort -u
	echo -en "\n[FSARCH]\n"; variable_parse FSARCH ";" | sort -u
	echo -en "\n[FSEXCL]\n"; variable_parse FSEXCL ";" | sort -u
	echo -en "\n"; common_packdirs_list
	return 0
}

################################################################################

function _prepare_build {		#{doredo} #{dofast} #{dotest}
	if ${DOREDO}; then
		_release_reset			|| return 1
	fi
	if ! ${DOFAST}; then
		DOREDO="false" _prepare_config	|| return 1
	fi
	DOTEST="${DOTEST}" _prepare_docdir	|| return 1
	_prepare_packages			|| return 1
	_prepare_repdir				|| return 1
	_prepare_linux				|| return 1
	DOREDO="false" _prepare_packdirs	|| return 1
	DOREDO="false" _prepare_symlinks	|| return 1
	return 0
}

########################################

function prepare_config_empty {
	if [[ -n $(${GREP} "${_GNAME}" ${TARGET}/etc/{issue,mod} 2>/dev/null) ]]; then
		return 1
	fi
	return 0
}

function prepare_config_issue {
	${RSYNC_C} --copy-links ${ARTDIR}/files/issue				${TARGET}/etc/issue	|| return 1
	for FILE in ${ROOTFS_FILE_VARS}; do
		${SED} -i "s|[$][{]${FILE}[}]|${!FILE}|g"			${TARGET}/etc/issue	|| return 1
	done
	if [[ -z ${COMMIT} ]] || [[ ! -d ${_G_REPO} ]]; then
		FILE=" "
#>>>		FILE+="\\\e[1;45;37m"
		FILE+="\\\e[0;35m"
		FILE+="PLEASE NOTE THAT THIS BUILD HAS BEEN CUSTOMIZED AND IS NOT AN OFFICIAL RELEASE"
		FILE+="\\\e[0;37m"
		${SED} -i "/Some helpful notes/,/Build system/c\\${FILE}"	${TARGET}/etc/issue	|| return 1
	fi
	if [[ ! -f ${TARGET}/usr/bin/startx ]]; then
		${SED} -i "/startx/d"						${TARGET}/etc/issue	|| return 1
	fi
	${SED}												\
		-e "s|[\]e[[]([0-9]+[;])?[0-9]+[;][0-9]+m||g"						\
		-e "/^[\][a-z]/d"									\
		${TARGET}/etc/issue						>${TARGET}/etc/motd
	return 0
}

function prepare_config_restore {	#>>>{doredo}
	declare PACK="${1}" && shift
	declare PFIL="${1}" && shift
	declare PSRC="${1}" && shift
	FILE="$(ls ${TARGET}${PAKDIR}/${PACK}-[.0-9]*.tbz2 2>/dev/null | sort | tail -n1)"
	if {
		[[ -n ${PACK} ]] &&
		[[ -f ${FILE} ]]
	}; then
		echo -en "\n"
		echo -en ">>> RESTORING (${PFIL}) FROM (${PACK}) PACKAGE FILE <<<\n"
		echo -en "\n"
		NEXT=".${PFIL}"
		if [[ -n ${PSRC} ]]; then
			NEXT="$(tar -t --bzip2 --wildcards -f ${FILE} "*/${PSRC}" | sort | tail -n1)"
			if [[ -z ${NEXT} ]]; then
				return 1
			fi
		fi
		tar -vvx --bzip2 -C ${TARGET} -f ${FILE} ${NEXT}		|| return 1
		if [[ -n ${PSRC} ]]; then
			NEXT="${NEXT/#.}"
			if [[ -n $(file ${TARGET}${NEXT} | ${GREP} "bzip2") ]]; then
				bzip2 -cd ${TARGET}${NEXT} >${TARGET}${PFIL}	|| return 1
			else
				${RSYNC_U} ${TARGET}${NEXT} ${TARGET}${PFIL}	|| return 1
			fi
		fi
		${RSYNC_U} ${TARGET}${PFIL} ${TARGET}${PFIL}.${_TITLE}		|| return 1
	elif {
		[[ -f ${PFIL}.${_TITLE} ]]
	}; then
		echo -en "\n"
		echo -en ">>> RESTORING (${PFIL}) FROM (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en "\n"
		${RSYNC_U} ${TARGET}${PFIL}.${_TITLE} ${TARGET}${PFIL}		|| return 1
	elif {
		[[ -n $(${GREP} "^${PACK}$" ${TARGET}${ETCDIR}/sets/${_PKG}) ]] ||
		[[ -n $(safe_env equery list '*' 2>&1 | ${GREP} "^${PACK}-[0-9]") ]]
	}; then
		echo -en "\n"
		echo -en ">>> NO (${PACK}) PACKAGE FILE OR (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en ">>> BUT THERE IS A (${PACK}) ENTRY IN THE (${_PKG}) SET OR IT IS INSTALLED <<<\n"
		echo -en ">>> LEAVING (${PFIL}) ALONE <<<\n"
		echo -en "\n"
	else
		echo -en "\n"
		echo -en ">>> NO (${PACK}) PACKAGE FILE OR (${PFIL}.${_TITLE}) BACKUP FILE <<<\n"
		echo -en ">>> NO (${PACK}) ENTRY IN THE (${_PKG}) SET AND IT IS NOT INSTALLED <<<\n"
		echo -en ">>> REMOVING (${PFIL}) FILE <<<\n"
		echo -en "\n"
		${RM} ${TARGET}${PFIL}						|| return 1
	fi
	if ${DOREDO}; then
		${RM} ${TARGET}${PFIL}.${_TITLE}				|| return 1
	fi
	return 0
}

#NOTE: UPDATE THE "SYSTEM INSTALLATION" TABLE IN "README" WHEN MAKING CHANGES HERE

#note: this is called statically in the "_system" script
function _prepare_config {		#{isexit} #{doredo}
	if {
		! ${DOREDO} &&
		[[ -z ${TARGET} ]];
	}; then
		if ! prepare_config_empty; then
			prepare_config_issue												|| return 1
		fi
		return 0
	fi
	#note: these are from the "prepare_config_issue" function above
	DOREDO="${DOREDO}" prepare_config_restore sys-apps/baselayout		/etc/issue						|| return 1
	DOREDO="${DOREDO}" prepare_config_restore "null"			/etc/motd						|| return 1
	#note: these are all directly below
	DOREDO="${DOREDO}" prepare_config_restore "null"			/init							|| return 1
	DOREDO="${DOREDO}" prepare_config_restore sys-apps/sysvinit		/etc/inittab						|| return 1
	DOREDO="${DOREDO}" prepare_config_restore sys-apps/baselayout		/etc/fstab						fstab			|| return 1
	DOREDO="${DOREDO}" prepare_config_restore sys-libs/glibc		/etc/locale.gen						|| return 1
	DOREDO="${DOREDO}" prepare_config_restore sys-apps/openrc		/etc/conf.d/hostname					|| return 1
	DOREDO="${DOREDO}" prepare_config_restore "null"			/etc/profile.d/setterm.sh				|| return 1
	DOREDO="${DOREDO}" prepare_config_restore net-wireless/wpa_supplicant	/etc/wpa_supplicant/wpa_supplicant.conf			wpa_supplicant.conf.bz2	|| return 1
	DOREDO="${DOREDO}" prepare_config_restore net-misc/openssh		/etc/ssh/sshd_config					|| return 1
	DOREDO="${DOREDO}" prepare_config_restore "null"			/etc/env.d/90xsession					|| return 1
	DOREDO="${DOREDO}" prepare_config_restore x11-wm/dwm			/etc/X11/Sessions/dwm					|| return 1
	if ${DOREDO}; then
		${SED} -i "s|^[#](en_US)|\1|g"					${TARGET}/etc/locale.gen				|| return 1
		safe_env							/usr/sbin/locale-gen					|| return 1
		safe_env							/usr/sbin/env-update					|| return 1
		return 0
	fi
	shopt -s lastpipe
	variable_parse RCUPDT ";" | while read -r FILE; do
		eval safe_env							${FILE}							|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	prepare_config_issue														|| return 1
	${LN} sbin/init								${TARGET}/init						|| return 1
	${SED} -i "s|^[#](.+ttyS0.+vt100.*)$|\1|g"				${TARGET}/etc/inittab					|| return 1
	${SED} -i "s|^([^#].+)$|#\1|g"						${TARGET}/etc/fstab					|| return 1
	${RSYNC_C} --copy-links ${ARTDIR}/files/locale.gen			${TARGET}/etc/						|| return 1
	${SED} -i "s|^(hostname=[\"]?)[^\"]+([\"]?)$|\1${_TITLE}\2|g"		${TARGET}/etc/conf.d/hostname				|| return 1
	echo -en "setterm -blength 0\n"						>${TARGET}/etc/profile.d/setterm.sh			|| return 1
	${RSYNC_C} --copy-links ${ARTDIR}/files/wpa_supplicant.conf		${TARGET}/etc/wpa_supplicant/				|| return 1
	${SED} -i "s|^.*(PermitRootLogin).*$|\1 yes|g"				${TARGET}/etc/ssh/sshd_config				|| return 1
	echo -en "XSESSION=\"${WINMGR}\"\n"					>${TARGET}/etc/env.d/90xsession				|| return 1
	FILE=																|| return 1
		FILE+="xset -b\n"													|| return 1
		FILE+="xsetroot -mod 3 3 -fg '#000000' -bg '#404040'\n"									|| return 1
	${SED} -i															\
		-e "/xset[ ][-]b/d"													\
		-e "/xsetroot[ ][-]mod/d"												\
		-e "s|^(exec[ ].*)$|${FILE}\1|g"											\
										${TARGET}/etc/X11/Sessions/dwm				|| return 1
	${SED} -i "s|^(.*xsetroot[ ][-]name[ ]).*$|\1\"${WMHELP}\"|g"		${TARGET}/etc/X11/Sessions/dwm				|| return 1
	safe_env								/usr/sbin/locale-gen					|| return 1
	safe_env								/usr/sbin/env-update					|| return 1
	echo -en "${_TITLE}\n${_TITLE}\n" | safe_env				/usr/bin/passwd root					|| return 1
	return 0
}

########################################

#note: cross-reference with the "release_install" function any time this changes
function _prepare_docdir {		#{dotest}
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	declare G_REPO_GIT="${_G_REPO}.git"
	declare G_REPO_SRC="${_G_REPO}"
	declare G_REPO_OPT=
	if [[ -n ${COMMIT} ]] && [[ -d ${_G_REPO} ]]; then
		if ${DOTEST} && {
			[[ -s ${SETDIR}/.gitignore ]] &&
			[[ -s ${SETDIR}/Makefile ]];
		}; then
			G_REPO_SRC="${SETDIR}"
			G_REPO_OPT="--copy-links"
		fi
	elif {
		[[ -s ${SETDIR}/.gitignore ]] &&
		[[ -s ${SETDIR}/Makefile ]];
	}; then
		G_REPO_GIT="${SETDIR}/.git"
		G_REPO_SRC="${SETDIR}"
		G_REPO_OPT=
	else
#>>>		${RM}					${TARGET}/.${_TITLE}			|| return 1
		return 0
	fi
	${MKDIR}					${TARGET}/.${_TITLE}			|| return 1
	#note: cross-reference with the "release_unpack" function any time this changes
	eval ${RSYNC_U} ${G_REPO_OPT} --delete-excluded						\
		--filter="-_/.git"								\
		--filter="P_/.git"								\
		$(${GREP} -v -e "^[#]" -e "^$" ${SETDIR}/.gitignore | while read -r FILE; do
			echo "--filter=\"-_${FILE/%\/}\""
		done)										\
		--filter="-_/build.${_GINST/#\/.}"						\
		${G_REPO_SRC}/				${TARGET}/.${_TITLE}			|| return 1
	if [[ -d ${G_REPO_GIT} ]]
	then ${RSYNC_U} ${G_REPO_GIT}/			${TARGET}/.${_TITLE}/.git		|| return 1
	else ${RM}					${TARGET}/.${_TITLE}/.git		|| return 1
	fi
	${SED} -i "/worktree[ ][=]/d"			${TARGET}/.${_TITLE}/.git/config	|| return 1
	#note: set the "makefile" to use "/" as the "$target" by default
	${RM}						${TARGET}/.${_TITLE}/build		|| return 1
	${LN} "/"					${TARGET}/.${_TITLE}/build		|| return 1
	#note: the configuration files need to match the current state when everything is unpacked
	#note: except if this is being called by the "release_install" function
	if [[ ${TARGET} != ${_GINST} ]]; then
		${SED} -i									\
			-e "s|^(override DOMODS[[:space:]]+[?][=][ ]).+$|\1${DOMODS}|g"		\
			-e "s|^(override P[[:space:]]+[?][=][ ]).+$|\1${_PKG}|g"		\
							${TARGET}/.${_TITLE}/Makefile		|| return 1
		portage_file				${TARGET}/.${_TITLE}/gentoo		|| return 1
	fi
	return 0
}

########################################

function _prepare_packages {
	if [[ -z ${TARGET} ]]; then
		${RM} ${TARGET}/.${_GPACK}								|| return 1
		return 0
	fi
	cat /dev/null >${TARGET}/.${_GPACK}								|| return 1
	for FILE in $(
		cd ${TARGET}${PAKDIR}									&&
		find ./ -mindepth 2 -maxdepth 2 -type f							|
			${SED} "s|^[.][/]||g"								|
			sort -u
	); do
		declare PKG_DB="$(cd ${TARGET}${PDBDIR} && ${LS} -d ${FILE/%.tbz2}	2>/dev/null)"	|| return 1
		declare PKG_DU="$(cd ${TARGET}${PAKDIR} && ${DU} -ks ${FILE}		2>/dev/null)"	|| return 1
		if [[ -n ${PKG_DB} ]]; then
			echo -en "${PKG_DU} (installed)\n"	| tee -a ${TARGET}/.${_GPACK}		|| return 1
		else
			echo -en "${PKG_DU} (packaged)\n"	| tee -a ${TARGET}/.${_GPACK}		|| return 1
		fi
	done
	declare PACK_FILE="${_RAMFS}.kernel.${_GPACK}"
	if ${ROOTFS_CUST}; then
		PACK_FILE="${_RAMFS}.rootfs.${_GPACK}"
	fi
	${MKDIR}			${_FINAL}							|| return 1
	${RSYNC_U} ${TARGET}/.${_GPACK}	${PACK_FILE}							|| return 1
	return 0
}

########################################

function _prepare_repdir {
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	declare REP_FILE="${TARGET}${ARCDIR}/$(basename ${REPDIR})"
	if [[ -f ${REP_FILE}.tar.xz ]] && [[ -f ${REP_FILE}.git.tar.xz ]]; then
		${RSYNC_U} ${REP_FILE}.tar.xz			${TARGET}${REPDIR}.tar.xz		|| return 1
		${RSYNC_U} ${REP_FILE}.git.tar.xz		${TARGET}${REPDIR}.git.tar.xz		|| return 1
	fi
	if [[ ! -f ${TARGET}${REPDIR}.tar.xz ]] || [[ ! -f ${TARGET}${REPDIR}.git.tar.xz ]]; then
		${RM}						${REP_FILE}{,.git}.tar.xz		|| return 1
		${RM}						${TARGET}${REPDIR}{,.git}{,.tar.xz}	|| return 1
		if [[ -d ${GITDIR} ]]; then
			${MKDIR}				${TARGET}${REPDIR}.git			|| return 1
			${RSYNC_U} ${GITDIR}/			${TARGET}${REPDIR}.git			|| return 1
		fi
		safe_env ${MYSELF} ${QUIET_OPT} ${TOOR} ${AUTO} -U ${FUNTOO}				|| return 1
		common_tar					${TARGET}${REPDIR}			|| return 1
		common_tar					${TARGET}${REPDIR}.git			|| return 1
	fi
	if [[ ! -d ${TARGET}${REPDIR} ]] || [[ ! -d ${TARGET}${REPDIR}.git ]]; then
		${RM}						${TARGET}${REPDIR}{,.git}		|| return 1
		common_untar					${TARGET}${REPDIR}			|| return 1
		common_untar					${TARGET}${REPDIR}.git			|| return 1
	fi
	if [[ ! -f ${REP_FILE}.tar.xz ]] || [[ ! -f ${REP_FILE}.git.tar.xz ]]; then
		${RSYNC_U} ${TARGET}${REPDIR}.tar.xz		${REP_FILE}.tar.xz			|| return 1
		${RSYNC_U} ${TARGET}${REPDIR}.git.tar.xz	${REP_FILE}.git.tar.xz			|| return 1
	fi
	return 0
}

########################################

function prepare_linux_directory {
	declare DODIR="${1}" && shift
	if [[ ! -d ${TARGET}${DODIR} ]]; then
		${RM}						${TARGET}${DODIR}.${_TITLE}	|| return 1
		${MKDIR}					${TARGET}${DODIR}.${_TITLE}	|| return 1
		tar -vvx --bzip2								\
			-C ${TARGET}${DODIR}.${_TITLE}						\
			-f ${TARGET}${PAKDIR}/*/gentoo-sources-${KVER}.tbz2			|| return 1
		${MV} ${TARGET}${DODIR}.${_TITLE}${KDIR}	${TARGET}${DODIR}		|| return 1
		${RM}						${TARGET}${DODIR}.${_TITLE}	|| return 1
		safe_env make -C ${DODIR}			distclean			|| return 1
	fi
	return 0
}

function _prepare_linux {
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	if [[ ! -f ${TARGET}${LDIR}.tar.xz ]]; then
		${RM}					${TARGET}${LDIR}		|| return 1
#>>>		prepare_linux_directory			${TARGET}${LDIR}		|| return 1
		prepare_linux_directory			${LDIR}				|| return 1
		${RSYNC_U} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${LDIR}/.config	|| return 1
		safe_env make -C ${LDIR}		modules_prepare			|| return 1
		common_tar				${TARGET}${LDIR}		|| return 1
	fi
	return 0
}

########################################

#note: companion to the "release_unpack" function
function _prepare_packdirs {		#{isexit} #{doredo}
	if ${DOREDO}; then
		${RM} $(variable_parse PACKDIRS_LIST "" "${TARGET}" ".tar.xz")
		echo -en "\n"
		echo -en ">>> LOCATING ANY PACKDIRS THAT MIGHT HAVE BEEN MISSED <<<\n"
		echo -en ">>> IT IS NORMAL FOR THIS TO TAKE SEVERAL MINUTES <<<\n"
		echo -en "\n"
		NEXT="$(eval find ${TARGET} \
			$(variable_parse DEVDIRS "" "\\( -path ${TARGET}" " -prune \\) -o ") \
			$(variable_parse PACKDIRS_SKIP "" "\\( -path ${TARGET}" " -prune \\) -o ") \
			\\\( -path ${_FINAL} -prune \\\) -o \
			\\\( -path ${TARGET}${ARCDIR} -prune \\\) -o \
			\\\( -path ${TARGET}${DSTDIR} -prune \\\) -o \
			\\\( -path ${TARGET}${PAKDIR} -prune \\\) -o \
			-print |
			${GREP} "[.]tar[.]xz$"
		)"
		if [[ -n ${NEXT} ]]; then
			${LL} ${NEXT} | ${GREP} "[^/]+[.]tar[.]xz$"
			return 1
		fi
		return 0
	fi
	shopt -s lastpipe
	#note: packing them in reverse, so that embedded packdirs get included
	variable_parse PACKDIRS | sort -r | while read -r FILE; do
		eval common_tar ${TARGET}${FILE} $(
			variable_parse FSEXCL ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
					echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
				fi
			done
			variable_parse FSARCH ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
					echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
				fi
			done
			variable_parse FSKEEP ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
				fi
			done
			variable_parse FSPACK ";" | while read -r NEXT; do
				if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
					echo "--exclude=\"${NEXT/#${FILE}\/}\""
				fi
			done
		) || return 1
	done
	shopt ${LASTPIPE} lastpipe
	echo -en "\n"; common_packdirs_list
	return 0
}

########################################

#note: companion to the "release_fetch" function
function _prepare_symlinks {		#{isexit} #{doredo}
	if [[ -z ${TARGET} ]]; then
		return 0
	fi
	declare REP_FILE="$(basename ${REPDIR})"
	${RM} $(find ${_FINAL} -maxdepth 1 -type l 2>/dev/null | sort)							|| return 1
	if ${DOREDO}; then
		return 0
	fi
	if [[ -n ${COMMIT} ]]
		#note: also doing this in "_system" script on purpose
		then echo -en "${COMMIT}"				>${TARGET}/${CMTFIL}				|| return 1
		else ${RM}						${TARGET}/${CMTFIL}				|| return 1
	fi
	${MKDIR} ${_FINAL}												|| return 1
	[[ -n ${COMMIT} ]] && ${LN} --relative ${TARGET}/${CMTFIL}	${_FINAL}/${CMTFIL}				|| return 1
	${LN} --relative ${TARGET}/.${_TITLE}/README.md			${_RAMFS}.${_GREAD}				|| return 1
	${LN} --relative ${_RAMFS}.kernel.${_GPACK}			${_FINAL}/${_GPACK}				|| return 1
	${LN} --relative ${_RAMFS}.rootfs.${_GPACK}			${_FINAL}/${_GPACK/%.txt/.${ROOTFS_NAME}.txt}	|| return 1
	${LN} --relative ${TARGET}${ARCDIR}				${_FINAL}${ARCDIR}				|| return 1
	${LN} --relative ${TARGET}${GENDIR}				${_FINAL}${GENDIR}				|| return 1
	${LN} --relative ${TARGET}${DSTDIR}				${_FINAL}/_$(basename ${DSTDIR})		|| return 1
	${LN} --relative ${TARGET}${PAKDIR}				${_FINAL}/_$(basename ${PAKDIR})		|| return 1
	${LN} --relative ${TARGET}${ARCDIR}/${REP_FILE}.tar.xz		${_RAMFS}.${REP_FILE}.tar.xz			|| return 1
	${LN} --relative ${TARGET}${ARCDIR}/${REP_FILE}.git.tar.xz	${_RAMFS}.${REP_FILE}.git.tar.xz		|| return 1
	shopt -s lastpipe
	variable_parse PACKDIRS | while read -r FILE; do
		${LN} --relative ${TARGET}${FILE}.tar.xz		${_FINAL}/$(common_packdir ${FILE})		|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	for FILE in ${TARGET}${ARCDIR}/stage3-*.tar.xz; do
		${LN} --relative ${FILE}				${_FINAL}/					|| return 1
	done
#>>>	${RM} $(find -L ${_FINAL} -maxdepth 1 -type l 2>/dev/null | sort)						|| return 1
	return 0
}

################################################################################

function _release_devel {		#{ismain} #{doredo} #{dotest}
	DOTEST="true" _prepare_docdir							|| return 1
	if ${DOTEST}; then
		DOREDO="false" DOFAST="true" DOTEST="true" _release_cpio		|| return 1
	else
		if ${DOREDO}; then
			#note: all "prepare_*" functions that "#{isexit}" on "${doredo}"
#>>>			DOREDO="true" _prepare_config					|| return 1
			DOREDO="true" _prepare_packdirs					|| return 1
#>>>			DOREDO="true" _prepare_symlinks					|| return 1
			DOREDO="false" DOFAST="false" DOTEST="true" _prepare_build	|| return 1
		fi
		DOREDO="false" _prepare_config						|| return 1
		DOREDO="true" DOFAST="true" DOTEST="false" _release_cpio		|| return 1
	fi
	DOREDO="true" _release_kernel							|| return 1
	if [[ ! -f ${_RAMFS}.rootfs ]]; then
		touch ${_RAMFS}.rootfs							|| return 1
	fi
	if [[ ! -f ${_RAMFS}.rootfs.packages.txt ]]; then
		touch ${_RAMFS}.rootfs.packages.txt					|| return 1
	fi
	if {
		${DOREDO} ||
		[[ ! -d ${_RAMFS}.grub ]];
	}; then
		DOREDO="true" DOFAST="true" DOTEST="true" _release_grub			|| return 1
	else
		DOREDO="false" DOFAST="true" DOTEST="true" _release_grub		|| return 1
	fi
	DOREDO="true" _prepare_symlinks							|| return 1
	_release_report									|| return 1
	return 0
}

########################################

function _release_build {		#{ismain} #{doredo} #{dofast} #{dotest}
	DOREDO="${DOREDO}" DOFAST="${DOFAST}" DOTEST="${DOTEST}" _prepare_build	|| return 1
	DOREDO="false" DOFAST="${DOFAST}" DOTEST="${DOTEST}" _release_cpio	|| return 1
	DOREDO="false" _release_kernel						|| return 1
	DOREDO="false" DOFAST="${DOFAST}" DOTEST="${DOTEST}" _release_grub	|| return 1
	_release_report								|| return 1
	return 0
}

########################################

function release_rootfs_cpio_tools {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	declare BUSY_DIR="$(dirname			${ROOTFS_BUSYBOX})"
	${MKDIR}					${ROOTFS_DEST}.dir${BUSY_DIR}		|| return 1
	${RSYNC_U} ${TARGET}${ROOTFS_BUSYBOX}		${ROOTFS_DEST}.dir${ROOTFS_BUSYBOX}	|| return 1
	chroot						${ROOTFS_DEST}.dir ${ROOTFS_BUSYBOX}	\
							--install -s ${BUSY_DIR}		|| return 1
	declare CORE_DIR="$(dirname			${ROOTFS_COREUTILS})"
	${MKDIR}					${ROOTFS_DEST}.dir${CORE_DIR}		|| return 1
	${RSYNC_U} ${TARGET}${ROOTFS_COREUTILS}		${ROOTFS_DEST}.dir${ROOTFS_COREUTILS}	|| return 1
	for FILE in $(
		${TARGET}${ROOTFS_COREUTILS} --help | ${GREP} "^[[:space:]]*[[]"
	); do
		${LN} --relative			${ROOTFS_DEST}.dir${ROOTFS_COREUTILS}	\
							${ROOTFS_DEST}.dir${BUSY_DIR}/${FILE}	|| return 1
		${LN} --relative			${ROOTFS_DEST}.dir${ROOTFS_COREUTILS}	\
							${ROOTFS_DEST}.dir${CORE_DIR}/${FILE}	|| return 1
	done
	return 0
}

function release_rootfs_cpio_utils {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	for FILE in ${ROOTFS_UTILS}; do
		${MKDIR}				${ROOTFS_DEST}.dir$(dirname ${FILE})	|| return 1
		if [[ -L				${ROOTFS_DEST}.dir${FILE}		]]; then
			${RM}				${ROOTFS_DEST}.dir${FILE}		|| return 1
		fi
		${RSYNC_U} --copy-links			${TARGET}${FILE}			\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		${MKDIR}				${ROOTFS_DEST}.dir/lib			|| return 1
		for NEXT in $(
			${ROOTFS_LDD}			${FILE}					|
			${GREP} --only-matching		"[/][^[:space:]]+"			\
		); do
			${RSYNC_U} --copy-links		${TARGET}${NEXT}			\
							${ROOTFS_DEST}.dir/lib/			|| return 1
		done
	done
	return 0
}

function release_rootfs_cpio_files {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	for FILE in ${ROOTFS_FILES}; do
		${MKDIR}				${ROOTFS_DEST}.dir$(dirname ${FILE})	|| return 1
		${RSYNC_C} --copy-links			${ARTDIR}/files/$(basename ${FILE})	\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		for NEXT in ${ROOTFS_FILE_VARS}; do
			${SED} -i "s|[$][{]${NEXT}[}]|${!NEXT}|g"				\
							${ROOTFS_DEST}.dir${FILE}		|| return 1
		done
	done
	touch						${ROOTFS_DEST}.dir/etc/passwd		\
							${ROOTFS_DEST}.dir/etc/group		|| return 1
	chroot						${ROOTFS_DEST}.dir ${ROOTFS_BUSYBOX}	\
							adduser					\
		-D -H -h / -u 0 -s ${ROOTFS_SHELL}	root					|| return 1
	echo -en "${_TITLE}\n${_TITLE}\n" | chroot	${ROOTFS_DEST}.dir ${ROOTFS_BUSYBOX}	\
							passwd root				|| return 1
	return 0
}

function release_rootfs_cpio {		#>>>{dotest}
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	${RM}						${ROOTFS_DEST}.dir				|| return 1
	${MKDIR}					${ROOTFS_DEST}.dir/dev				|| return 1
	realdev						${ROOTFS_DEST}.dir/dev				|| return 1
	release_rootfs_cpio_tools			${ROOTFS_DEST}					|| return 1
	release_rootfs_cpio_utils			${ROOTFS_DEST}					|| return 1
	release_rootfs_cpio_files			${ROOTFS_DEST}					|| return 1
	${LN} --relative				${ROOTFS_DEST}.dir/lib				\
							${ROOTFS_DEST}.dir/lib64			|| return 1
	${LN} --relative				${ROOTFS_DEST}.dir${ROOTFS_BUSYBOX}		\
							${ROOTFS_DEST}.dir/init				|| return 1
	echo -en "\n"
	${DU_L}						${ROOTFS_DEST}.dir				|| return 1
	(cd ${ROOTFS_DEST}.dir && ${LL} --directory	$(find ./ ! -type l | ${SED} "s|^[.][/]||g"))	|| return 1
	if ${DOTEST}; then
		echo -en "\n"
		safe_env equery belongs			${ROOTFS_BUSYBOX}				\
							${ROOTFS_COREUTILS}				\
							${ROOTFS_UTILS}					|| return 1
		sort -u					${SETDIR}/${FUNDIR}/sets/${_PKG} | ${GREP} "#{rootfs}"
	fi
	${RSYNC_U} ${ROOTFS_DEST}			${ROOTFS_DEST}.dir${ROOTFS_ROOT}		|| return 1
	return 0
}

#note: this function is intentionally not in the right order of usage, for readability
function release_rootfs_file {
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	${MKDIR}			$(dirname ${ROOTFS_DEST})				|| return 1
	cat /dev/null			>${ROOTFS_DEST}.exclude					|| return 1
	variable_parse SKIPDIRS | ${SED}							\
					-e "s|^/||g"						\
					>>${ROOTFS_DEST}.exclude				|| return 1
	${SED} -i "/^dev\//d"		${ROOTFS_DEST}.exclude					|| return 1
	${RM}				${TARGET}/tmp/${_TITLE}.dev				|| return 1
	${MKDIR}			${TARGET}/tmp/${_TITLE}.dev				|| return 1
	realdev				${TARGET}/tmp/${_TITLE}.dev				|| return 1
	for FILE in $(cd		${TARGET}/dev && find ./); do				declare SKIP="true"
		for NEXT in $(cd	${TARGET}/tmp/${_TITLE}.dev && find ./); do		if [[ ${FILE} == ${NEXT} ]]; then SKIP="false"; fi
		done;										if ${SKIP}; then echo "${FILE/#\./dev}"; fi
	done				>>${ROOTFS_DEST}.exclude				|| return 1
	${RM}				${TARGET}/tmp/${_TITLE}.dev				|| return 1
	mk${ROOTFS_TYPE} ${TARGET:-/}	${ROOTFS_DEST} ${ROOTFS_OPTS} ${ROOTFS_DEST}.exclude	|| return 1
	un${ROOTFS_TYPE} -lls		${ROOTFS_DEST} >${ROOTFS_DEST}.txt			|| return 1
	return 0
}

function _release_rootfs {		#{ismain} #{doredo} #{dofast} #{dotest}
	declare ROOTFS_DEST="${ROOTFS_FILE}"
	if [[ -n ${1} ]]; then
		ROOTFS_DEST="${1}" && shift
	fi
	if ${DOREDO}; then
		${RM}							${ROOTFS_DEST}*		|| return 1
	fi
	if [[ ${ROOTFS_DEST} == ${ROOTFS_FILE} ]]; then
		ROOTFS_CUST="true"
		if [[ ! -f ${ROOTFS_DEST} ]]; then
			if ${DOREDO}; then
				#note: all "prepare_*" functions that "#{isexit}" on "${doredo}"
#>>>				DOREDO="true" _prepare_config					|| return 1
				DOREDO="true" _prepare_packdirs					|| return 1
#>>>				DOREDO="true" _prepare_symlinks					|| return 1
			fi
			DOREDO="false" DOFAST="${DOFAST}" DOTEST="${DOTEST}" _prepare_build	|| return 1
			release_rootfs_file				${ROOTFS_DEST}		|| return 1
		else
			common_exists ${FUNCNAME}			${ROOTFS_DEST}*		|| return 1
		fi
	else
		if [[ ! -f ${ROOTFS_DEST} ]]; then
			release_rootfs_file				${ROOTFS_DEST}		|| return 1
			DOTEST="${DOTEST}" release_rootfs_cpio		${ROOTFS_DEST}		|| return 1
		elif ${DOTEST}; then
			DOTEST="true" release_rootfs_cpio		${ROOTFS_DEST}		|| return 1
		else
			common_exists ${FUNCNAME}			${ROOTFS_DEST}*		|| return 1
		fi
	fi
	return 0
}

########################################

function release_cpio_nul {		#>>>{doredo} #>>>{dofast} #>>>{dotest}
	if ${ROOTFS}; then
		DOREDO="${DOREDO}" DOFAST="${DOFAST}" DOTEST="${DOTEST}" _release_rootfs	${CPIO_FILE}.${ROOTFS_NAME}	|| return 1
		(cd ${CPIO_FILE}.${ROOTFS_NAME}.dir && eval find ./ -mindepth 1 -xdev \
		-print0)									>${CPIO_FILE}.nul		|| return 1
	else
		#note: excluding them in reverse, so that embedded packdirs get included
		(cd ${TARGET} && eval find ./ -mindepth 1 -xdev \
			$(variable_parse SKIPDIRS | while read -r FILE; do
				if variable_match FSEXCL ";" "${FILE}"; then
					echo "\\( -path .${FILE/\*/\\\*} -prune \\) -o"
					echo "\\( -path .${FILE/\*/\\\*}.tar.xz -prune \\) -o"
				elif variable_match FSARCH ";" "${FILE}"; then
					echo "\\( -path .${FILE/\*/\\\*} -prune \\) -o"
					echo "\\( -path .${FILE/\*/\\\*}.tar.xz -prune \\) -o"
				elif variable_match FSKEEP ";" "${FILE}"; then
					echo "\\( -path .${FILE/\*/\\\*}.tar.xz -prune \\) -o"
				elif variable_match FSPACK ";" "${FILE}"; then
					echo "\\( -path .${FILE/\*/\\\*}.tar.xz -prune \\) -o"
				else
					echo "\\( -path .${FILE/\*/\\\*} -prune \\) -o"
				fi
			done) \
		-print0)									>${CPIO_FILE}.nul		|| return 1
		${RM}										${TARGET}/tmp/dev		|| return 1
		${MKDIR}									${TARGET}/tmp/dev		|| return 1
		realdev										${TARGET}/tmp/dev		|| return 1
		(cd ${TARGET}/tmp && find ./dev -print0)					>>${CPIO_FILE}.nul		|| return 1
		${RM}										${TARGET}/tmp/dev		|| return 1
	fi
	return 0
}

function release_cpio_file {
	if ${ROOTFS}; then
		(cd ${CPIO_FILE}.${ROOTFS_NAME}.dir && ${XARGS} ${DU_S})	| tee ${CPIO_FILE}.txt
		cat ${CPIO_FILE}.nul | ${CPIO_IN}				${CPIO_FILE}.${ROOTFS_NAME}.dir	|| return 1
	else
		(cd ${TARGET} && ${XARGS} ${DU_S})				| tee ${CPIO_FILE}.txt
		cat ${CPIO_FILE}.nul | ${CPIO_IN}				${TARGET}			|| return 1
	fi
	sort -k4 -u -o ${CPIO_FILE}.txt						${CPIO_FILE}.txt		|| return 1
	${RM}									${CPIO_FILE}.nul		|| return 1
	return 0
}

function release_cpio_dir {		#>>>{dofast} #>>>{dotest}
	if ! ${ROOTFS}; then
		${RM}			${CPIO_FILE}.dir	|| return 1
		${MKDIR}		${CPIO_FILE}.dir	|| return 1
		${CPIO_OUT}		${CPIO_FILE}.dir	|| return 1
	fi
	if {
		! ${DOFAST} &&
		! ${DOTEST};
	}; then
		${XZ} ${CPIO_FILE}	>${CPIO_FILE}.xz	|| return 1
	fi
	return 0
}

function _release_cpio {		#{doredo} #{dofast} #{dotest}
	if ${DOREDO}; then
		${RM} ${CPIO_FILE}*								|| return 1
	elif ${ROOTFS} && ${DOTEST}; then
		${RM} ${CPIO_FILE}								|| return 1
	fi
	${MKDIR} ${_FINAL}									|| return 1
	if [[ ! -f ${CPIO_FILE} ]]; then
		${RM} ${_RAMFS}.kernel								|| return 1
		DOREDO="${DOREDO}" DOFAST="${DOFAST}" DOTEST="${DOTEST}" release_cpio_nul	|| return 1
		release_cpio_file								|| return 1
		DOFAST="${DOFAST}" DOTEST="${DOTEST}" release_cpio_dir				|| return 1
	else
		common_exists ${FUNCNAME} ${CPIO_FILE}*						|| return 1
	fi
	return 0
}

########################################

function release_kernel_patch {
	declare DODIR="${1}" && shift
	for FILE in ${PATCHES[*]}; do
		${PATCH} --directory=${TARGET}${DODIR} --reverse	<${PATCH_DIR}/${FILE}	#>>> || return 1
		${PATCH} --directory=${TARGET}${DODIR}			<${PATCH_DIR}/${FILE}	|| return 1
	done
	return 0
}

function release_kernel_config {
	declare DODIR="${1}" && shift
	if [[ -z ${TARGET} ]]; then	${RSYNC_U} ${SETDIR}/${LINDIR}/${KCFG}	${TARGET}${DODIR}/.config	|| return 1
	else				${RSYNC_U} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${DODIR}/.config	|| return 1
	fi
	kernel_cpu								${TARGET}${DODIR}/.config	|| return 1
	return 0
}

#note: the final "shmem" needs to be more than twice the size of the final internal "rootfs" in order for the in-memory transfer to work
#note: heavy use of "$fspack" should be enough to create this offset
function release_kernel_shmem {
	declare DODIR="${1}" && shift
	#note: treating the size of the ".cpio" as the in-memory filesystem size, adding buffer and free disk space, and then rounding pages
	#note: the "$fspack" directories are ".tar.xz" compressed, so also calculating their final cost once they are unpacked and the archives are deleted
	#note: the "$fspack" calculation also factors in the status of subdirectories
	#note: none of this is perfect, but it is close enough
	declare SHMEM_PAGES="4096"
	declare SHMEM="$(${DU_S} ${CPIO_FILE} | ${SED} "s|[[:space:]].*$||g")"
	declare PRINTF=" %10.10s %10.10s %10.10s %10.10s %10.10s\n"
	printf "%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s" ">>> INITIAL SHMEM: ${SHMEM}"
	printf "${PRINTF}" "~ SIZE" "+ COST" "- PACK" "@ DIFF" "= SHMEM"
	shopt -s lastpipe
	variable_parse FSPACK ";" | while read -r FILE; do
		#note: the "if" subshell is to work around a "lastpipe" error when the last item in the "$fspack" list is excluded
		if [[ -n $(if {
			! variable_match "FSKEEP FSARCH FSEXCL" ";" "${FILE}" &&
			! variable_match "FSKEEP FSARCH FSEXCL" ";" "${FILE}" true;
		}; then
			echo "true"
		fi) ]]; then
			printf "%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s" ">>> PACKDIR: ${FILE}"
			if [[ ! -d ${TARGET}${FILE} ]] || [[ ! -f ${TARGET}${FILE}.tar.xz ]]; then
				echo -en "\n"
				common_exists ${FUNCNAME} ${TARGET}${FILE} ${TARGET}${FILE}.tar.xz
				return 1
			fi
			declare S_VAL="$(${DU_S} ${TARGET}${FILE}		2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			#note: counting them in reverse, so that embedded packdirs get excluded
			declare S_ADD="$(eval ${DU_S} ${TARGET}${FILE} $(
				variable_parse FSEXCL | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
				variable_parse FSARCH | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
				variable_parse FSKEEP | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}\""
					fi
				done
				variable_parse FSPACK | while read -r NEXT; do
					if [[ ${NEXT/#${FILE}\/} != ${NEXT} ]]; then
						echo "--exclude=\"${NEXT/#${FILE}\/}.tar.xz\""
					fi
				done
			)							2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			declare S_SUB="$(${DU_S} ${TARGET}${FILE}.tar.xz	2>/dev/null | ${SED} "s|[[:space:]].*$||g")"
			declare S_TOT="$(echo "${S_ADD}-${S_SUB}" | bc)"
			SHMEM="$(echo "${SHMEM}+${S_TOT}" | bc)"
			printf "${PRINTF}" "${S_VAL}" "${S_ADD}" "${S_SUB}" "${S_TOT}" "${SHMEM}"
		fi
	done
	shopt ${LASTPIPE} lastpipe
	echo -en ">>> TOTAL SHMEM: ${SHMEM}\n"
	SHMEM="$(echo "((${SHMEM}+(${SHMEM_MEM}))/${SHMEM_PAGES})" | bc | ${SED} -r "s|[.].*$||g")"
	SHMEM="$(echo "(${SHMEM}*${SHMEM_PAGES})" | bc)"
	echo -en ">>> FINAL SHMEM: ${SHMEM}\n"
	echo "CONFIG_SHMEM_SIZE=\"${SHMEM}\"" >>${TARGET}${DODIR}/.config	|| return 1
	return 0
}

function release_kernel_initramfs {
	declare DODIR="${1}" && shift
	declare INITRAMFS_CONFIG=
	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_SOURCE=\"${CPIO_FILE/#${TARGET}}\"\n"
#>>>	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_ROOT_GID=0\n"
#>>>	INITRAMFS_CONFIG+="CONFIG_INITRAMFS_ROOT_UID=0\n"
	if ${ROOTFS}; then
		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION_NONE=y\n"
	else
		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION_XZ=y\n"
#>>>		INITRAMFS_CONFIG+="CONFIG_INITRAMFS_COMPRESSION=\".xz\"\n"
	fi
	${SED} -i \
		-e "/CONFIG_INITRAMFS_COMPRESSION/d" \
		-e "s|^.*(CONFIG_INITRAMFS_SOURCE)[^_].*$|${INITRAMFS_CONFIG}|g" \
		${TARGET}${DODIR}/.config			|| return 1
	${RM}	${TARGET}${DODIR}/usr/initramfs_data.cpio*	|| return 1
	return 0
}

function release_kernel_diff {
	declare DODIR="${1}" && shift
	${RSYNC_U} ${TARGET}${DODIR}/.config		${TARGET}${ARCDIR}/${KCFG}.initramfs	|| return 1
	${GREP} "CONFIG_(SHMEM|KERNEL|INITRAMFS|RD)_"	${TARGET}${ARCDIR}/${KCFG}.initramfs	|| return 1
	diff ${DIFF_OPTS} ${TARGET}${ARCDIR}/${KCFG}	${TARGET}${ARCDIR}/${KCFG}.initramfs	| ${GREP} "^[-+]"
	return 0
}

function release_kernel_build {
	declare DODIR="${1}" && shift
	declare KOUT="${1}" && shift
#>>>	declare BZIMAGE="${TARGET}${DODIR}/arch/x86_64/boot/bzImage"
	declare BZIMAGE="${TARGET}${DODIR}/arch/x86/boot/bzImage"
	declare BZ_MAKE="${TARGET}${DODIR}/arch/x86/Makefile"
	declare BZ_SEDR=".+ln -fsn.+/x86/boot/bzImage.+"
	if [[ -f ${BZ_MAKE}.${_TITLE} ]]; then ${MV}	${BZ_MAKE}{.${_TITLE},}	|| return 1; fi
	${SED} -i.${_TITLE} "s|^(${BZ_SEDR})$|\#\1|g"	${BZ_MAKE}		|| return 1
	safe_env make -C ${DODIR}			olddefconfig		|| return 1
	safe_env make -C ${DODIR}			bzImage			|| return 1
	${RSYNC_U} --copy-links ${BZIMAGE}		${KOUT}			|| return 1
	return 0
}

#note: ld: kernel image bigger than KERNEL_IMAGE_SIZE
#note: comments at the bottom of <kernel_source>/arch/x86/include/asm/page_64_types.h
function _release_kernel {		#{doredo}
	if ${DOREDO}; then
		${RM}						${_RAMFS}.kernel	|| return 1
	fi
	declare DODIR="${KDIR}"
	if [[ -z ${TARGET} ]]; then
		DODIR="${LDIR}"
	fi
	if [[ ! -f ${_RAMFS}.kernel ]]; then
		prepare_linux_directory		${DODIR}				|| return 1
		release_kernel_patch		${DODIR}				|| return 1
		release_kernel_config		${DODIR}				|| return 1
		release_kernel_shmem		${DODIR}				|| return 1
		release_kernel_initramfs	${DODIR}				|| return 1
		release_kernel_diff		${DODIR}				|| return 1
		release_kernel_build		${DODIR}	${_RAMFS}.kernel	|| return 1
	else
		common_exists ${FUNCNAME}						\
								${TARGET}${DODIR}	\
								${_RAMFS}.kernel	\
											|| return 1
	fi
	return 0
}

########################################

function release_grub_loopfile {	#>>>{dotest}
	declare GRUB_DEST="${1}" && shift
	declare GRUB_LEFI="${1}" && shift
	declare GRUB_LOOP="${1}" && shift
	if ${DOTEST}; then
		${MKDIR}						${GRUB_DEST}/.mount-loop-efi/${_TITLE}			|| return 1
		if ! ${RSYNC_W} --copy-links ${_RAMFS}.kernel		${GRUB_DEST}/.mount-loop-efi/${_TITLE}/${_TITLE}.efi	; then
			${RM}						${GRUB_DEST}/.mount-loop-efi/${_TITLE}/${_TITLE}.efi	|| return 1
			${RSYNC_W} --copy-links ${_RAMFS}.kernel	${GRUB_DEST}/.mount-loop-efi/${_TITLE}/${_TITLE}.efi	|| return 1
		fi
	fi
	${MKDIR}							${GRUB_DEST}/.mount-loop/${_TITLE}			|| return 1
	${RSYNC_W} --copy-links ${GRUB_DEST}/${_TITLE}.grub.cfg		${GRUB_DEST}/.mount-loop/${_TITLE}/			|| return 1
	if ! ${RSYNC_W} --copy-links ${_RAMFS}.kernel			${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.kernel	; then
		if [[ -f						${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.rootfs	]]; then
			${RM}						${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.rootfs	|| return 1
			${RSYNC_W} --copy-links ${_RAMFS}.kernel	${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.kernel	|| return 1
		else														return 1
	fi; fi
	if {
		${DOTEST} &&
		[[ -f ${_RAMFS}.rootfs ]];
	}; then
		${RSYNC_W} --copy-links ${_RAMFS}.rootfs		${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.rootfs	|| return 1
	else	${RM}							${GRUB_DEST}/.mount-loop/${_TITLE}/${_TITLE}.rootfs	|| return 1
	fi
	${LL} --recursive						${GRUB_DEST}/.mount-loop{-efi,}				|| return 1
	return 0
}

function release_grub_qcow_mount {	#>>>{dotest}
	declare GRUB_DEST="${1}" && shift
	declare GRUB_LEFI="${1}" && shift
	declare GRUB_LOOP="${1}" && shift
	modprobe			nbd max_part=127					|| return 1
	cat				/sys/module/nbd/parameters/max_part			|| return 1
	qemu-nbd --fork -nv -f qcow2 -c	${GRUB_LOOP/%p[0-9]} ${GRUB_DEST}/loopfile.qcow2	|| return 1
	if ! ${DOTEST}; then
		partx -t gpt -a		${GRUB_LOOP/%p[0-9]}					#>>> || return 1
		${MKDIR}		${GRUB_DEST}/.mount-loop{-efi,}				|| return 1
		mount			${GRUB_LEFI} ${GRUB_DEST}/.mount-loop-efi		|| return 1
		mount -o nonempty	${GRUB_LOOP} ${GRUB_DEST}/.mount-loop			|| return 1
	fi
	return 0
}

function release_grub_qcow_unmount {	#>>>{dotest}
	declare GRUB_DEST="${1}" && shift
	declare GRUB_LEFI="${1}" && shift
	declare GRUB_LOOP="${1}" && shift
	if ! ${DOTEST}; then
		umount	${GRUB_LEFI}			|| return 1
		umount	${GRUB_LOOP}			|| return 1
	fi
	qemu-nbd -d	${GRUB_LOOP/%p[0-9]}		|| return 1
	${RM}		${GRUB_DEST}/.mount-loop{-efi,}	|| return 1
	return 0
}

function _release_grub {		#{doredo} #{dofast} #{dotest}
	declare GRUB_DEST="${_RAMFS}.grub"
	declare GRUB_LEFI="/dev/nbd9p3"
	declare GRUB_LOOP="/dev/nbd9p1"
	declare QCOW_SIZE="100G"
	if ${DOREDO}; then
		${RM}							${GRUB_DEST}*						|| return 1
	fi
	if [[ ! -f ${GRUB_DEST}.tar.xz ]] && [[ ! -f ${GRUB_DEST}.zip ]]; then
		if {
			${DOREDO} ||
			! ${DOTEST};
		}; then
			${RM}						${GRUB_DEST}*						|| return 1
			${MKDIR}					${GRUB_DEST}						|| return 1
			${HOME}/scripts/grub.sh				${GRUB_DEST}						|| return 1
		fi
		if {
			${DOTEST} ||
			[[ ! -x $(which qemu-img) ]] ||
			[[ ! -x $(which qemu-nbd) ]];
		}; then
			${HOME}/scripts/grub.sh				${GRUB_DEST} -m						|| return 1
			DOTEST="false" release_grub_loopfile		${GRUB_DEST}						|| return 1
			${HOME}/scripts/grub.sh				${GRUB_DEST} -u						|| return 1
		fi
		if {
			[[ -x $(which qemu-img) ]] &&
			[[ -x $(which qemu-nbd) ]];
		}; then
			if ! ${DOTEST}; then
				qemu-img convert -O qcow2		${GRUB_DEST}/loopfile.img ${GRUB_DEST}/loopfile.qcow2	|| return 1
				qemu-img info				${GRUB_DEST}/loopfile.qcow2				|| return 1
			elif {
				${DOTEST} &&
				[[ ! -f ${GRUB_DEST}/loopfile.qcow2 ]];
			}; then
				qemu-img create -f qcow2		${GRUB_DEST}/loopfile.qcow2 ${QCOW_SIZE}		|| return 1
				DOTEST="true" release_grub_qcow_mount	${GRUB_DEST} ${GRUB_LEFI} ${GRUB_LOOP}			|| return 1
				${RM}					${GRUB_DEST}/${FUNCNAME}				|| return 1
				${MKDIR}				${GRUB_DEST}/${FUNCNAME}				|| return 1
				${HOME}/scripts/grub.sh			${GRUB_DEST}/${FUNCNAME} -f ${GRUB_LOOP}		|| return 1
				DOTEST="true" release_grub_qcow_unmount	${GRUB_DEST} ${GRUB_LEFI} ${GRUB_LOOP}			|| return 1
				sleep 1
			fi
			DOTEST="false" release_grub_qcow_mount		${GRUB_DEST} ${GRUB_LEFI} ${GRUB_LOOP}			|| return 1
			DOTEST="${DOTEST}" release_grub_loopfile	${GRUB_DEST}						|| return 1
			DOTEST="false" release_grub_qcow_unmount	${GRUB_DEST} ${GRUB_LEFI} ${GRUB_LOOP}			|| return 1
		fi
		if {
			! ${DOFAST} &&
			! ${DOTEST};
		}; then
			${RM}						${GRUB_DEST}/_*						|| return 1
			${RM}						${GRUB_DEST}/*.tar					|| return 1
			${WGET_C} -P					${GRUB_DEST} ${RUFUS_URL}				|| return 1
#>>>			common_tar					${GRUB_DEST}						|| return 1
			7z d						${GRUB_DEST}.zip					|| return 1
			7z a						${GRUB_DEST}.zip ${GRUB_DEST}				|| return 1
		fi
	else
		common_exists ${FUNCNAME}				${GRUB_DEST}*						|| return 1
	fi
	return 0
}

########################################

function _release_report {
	echo -en "\n"
	${LL}						\
		${TARGET}/				\
		${_FINAL}*				\
							2>/dev/null
	echo -en "\n"
	${DU_L} --dereference --one-file-system		\
		${TARGET}${LDIR}/usr/initramfs_data.*	\
		${_RAMFS}*				\
							2>/dev/null
	return 0
}

################################################################################

function release_fetch_list {		#>>>{dotest}
	declare FET_PKG="${1}" && shift
	declare MASK="# "
	if ${DOTEST}; then
		MASK=
	fi
	if {
		${DOTEST} ||
		[[ ! -s ${FET_PKG} ]];
	}; then
		cat /dev/null					>${FET_PKG}
		echo "${FET_BAS}.${_GREAD}"			>>${FET_PKG}
		echo "${FET_BAS}.kernel"			>>${FET_PKG}
		echo "${FET_BAS}.kernel.${_GPACK}"		>>${FET_PKG}
		echo "${MASK}${FET_BAS}.grub.zip"		>>${FET_PKG}
		echo "${MASK}${FET_BAS}.rootfs"			>>${FET_PKG}
		echo "${MASK}${FET_BAS}.rootfs.${_GPACK}"	>>${FET_PKG}
		shopt -s lastpipe
		variable_parse PACKDIRS | while read -r FILE; do
			echo "${MASK}$(common_packdir ${FILE})"	>>${FET_PKG}
		done
		shopt ${LASTPIPE} lastpipe
		echo "${MASK}stage3-${ESUB}.tar.xz"		>>${FET_PKG}
	else
		${SED} -i					\
			-e "s|^[[:space:]]+||g"			\
			-e "s|[[:space:]]+$||g"			\
			-e "/^$/d"				\
								${FET_PKG}	|| return 1
		sort -u -o ${FET_PKG}				${FET_PKG}	|| return 1
	fi
	return 0
}

#note: companion to the "prepare_symlinks" function
#note: also maps to the "release_unpack" function
function _release_fetch {		#{ismain} #{doredo} #{dotest}
	declare FET_DST="./${_TITLE}"
	declare FET_BAS="${_RAMFS/#${_FINAL}\/}"
	declare FET_PKG="${FET_DST}/${FET_BAS}.${FUNCNAME/#${MAKEIT}_}"
	if ${DOREDO}; then
		${RM}							${FET_DST}/*					|| return 1
	fi
	${MKDIR}							${FET_DST}					|| return 1
	DOTEST="${DOTEST}" release_fetch_list				${FET_PKG}					|| return 1
	for FILE in $(${GREP} -v "^[#]" ${FET_PKG}); do
#>>>		if [[ -f						${FET_DST}/${FILE} ]] && ! ${DOTEST}; then continue; fi
		if [[ -f						${_FINAL}/${FILE} ]]
		then ${RSYNC_U} --copy-links ${_FINAL}/${FILE}		${FET_DST}/					|| return 1
		else ${WGET_C} --directory-prefix			${FET_DST}/ ${_SFDOWN}/${FILE}			|| return 1
		fi
	done
	if {	[[ -f							${FET_DST}/${FET_BAS}.grub.zip ]] &&
		[[ ! -d							${FET_DST}/${_TITLE}.grub ]];
	}; then
		7z e -aoa \
			-x\!\*/loopfile\* \
			-x\!\*/rufus\* \
			-o${FET_DST}/${_TITLE}.grub			${FET_DST}/${FET_BAS}.grub.zip			|| return 1
		${RM}							${FET_DST}/${_TITLE}.grub/${FET_BAS}.grub	|| return 1
	fi
	for FILE in kernel rootfs; do
		if {	[[ -f						${FET_DST}/${FET_BAS}.${FILE} ]] &&
			[[ ! -f						${FET_DST}/${_TITLE}.${FILE} ]];
		}; then
			${LN}		${FET_BAS}.${FILE}		${FET_DST}/${_TITLE}.${FILE}			#>>> ||
#>>>			${RSYNC_C}	${FET_DST}/${FET_BAS}.${FILE}	${FET_DST}/${_TITLE}.${FILE}			|| return 1
		fi
	done
	(cd ${FET_DST};
		echo -en "\n"; ${LL}
		echo -en "\n"; ${DU_L} *
	)
	echo -en "\n"; ${LL} ${FET_PKG}; cat ${FET_PKG}
	return 0
}

########################################

#note: companion to the "prepare_packdirs" function
function _release_unpack {		#{ismain} #{doredo} #{dotest}
	declare UNPACK="${TARGET}${_GUNPK}"
	declare DOINST="${TARGET}${_GINST}/${_TITLE}"
	declare CREGEX+="([a-z]+[${PACKDIRS_CSEP}])?"
	declare FREGEX="(([[:space:]]+[(]).*([)]))?"
	declare PRINTF="%-${PACKDIRS_PRNT}.${PACKDIRS_PRNT}s %s\n"
	declare SORTER="-k1.2"
	#note: doing some other helpful things when in a live filesystem environment
	#note: cross-reference with the "prepare_docdir" function any time this changes
	#note: cross-reference with the "release_install" function any time this changes
	if [[ -z ${TARGET} ]]; then
		#note: for "release_install" function
		if [[ ! -d ${_GINST} ]]; then
			${RM}		${_GINST}						|| return 1
			${MKDIR}	${_GINST}						|| return 1
		fi
		#note: for "release_unpack" function
#>>>		if [[ ! -d ${DOINST} ]]; then
#>>>			${RM}		${DOINST}						|| return 1
#>>>			${MKDIR}	${DOINST}						|| return 1
#>>>		fi
		#note: for all "release_*" functions
		if [[ ! -d ${_FINAL} ]]; then
			${RM}		${_FINAL}						|| return 1
			${LN}		${DOINST}	${_FINAL}				|| return 1
		fi
		#note: for mapping between the "release_fetch" function and this one
		if [[ ! -d /.${_TITLE}/${_TITLE} ]]; then
			${RM}		/.${_TITLE}/${_TITLE}					|| return 1
			${LN}		${DOINST}	/.${_TITLE}/${_TITLE}			|| return 1
		fi
		#note: set the "makefile" to use "$_title" as the "$source" by default
		if [[ ! -d /.${_TITLE}/sources ]]; then
			${RM}		/.${_TITLE}/sources					|| return 1
			${LN}		${_TITLE}	/.${_TITLE}/sources			|| return 1
		fi
		#note: dummy pointer to set the "makefile" to use "$_ginst" as the "$target" by default
		if [[ ! -L /.${_TITLE}/build.${_GINST/#\/.} ]]; then
			${RM}		/.${_TITLE}/build.${_GINST/#\/.}			|| return 1
			${LN}		${_GINST}	/.${_TITLE}/build.${_GINST/#\/.}	|| return 1
		fi
	fi
	if ${DOREDO}; then
		variable_parse PACKDIRS_LIST | sort -u						>${UNPACK}		|| return 1
	fi
	if [[ ! -f ${UNPACK} ]]; then
		shopt -s lastpipe
		variable_parse FSPACK ";" | while read -r FILE; do
			if ! variable_match "FSKEEP FSARCH FSEXCL" ";" "${FILE}"; then
				echo "${FILE}"							>>${UNPACK}		|| return 1
			fi
		done
		shopt ${LASTPIPE} lastpipe
	fi
	echo "# ${PACKDIRS_KEEP}<directory> = fetch/unpack directory, keep archive"		>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_INST}<directory> = fetch/unpack directory, remove archive"		>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_PACK}<directory> = remove directory, keep archive"			>>${UNPACK}		|| return 1
	echo "# ${PACKDIRS_GONE}<directory> = remove directory, remove archive"			>>${UNPACK}		|| return 1
	printf "${PRINTF}"												\
		"#${PACKDIRS_MARK} <none><directory> = ${PACKDIRS_DEFL}<directory>"					\
		"(<file>) = local archive"										\
												>>${UNPACK}		|| return 1
	shopt -s lastpipe
	variable_parse PACKDIRS "" "" "" true | while read -r FILE; do
		declare PFIL="${FILE/#*${PACKDIRS_CSEP}}"
		declare PSRC="$(common_packdir ${PFIL})"
		if variable_match FSEXCL ";" ${PFIL}; then
			echo -en ">>> EXCLUDING: ${PFIL}\n"
			continue
		fi
		if {
			[[ -z $(${GREP} "^${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_KEEP}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_INST}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_PACK}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]] &&
			[[ -z $(${GREP} "^[${PACKDIRS_GONE}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]
		}; then
			if [[ -d ${TARGET}${PFIL} ]] && [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_KEEP}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ -d ${TARGET}${PFIL} ]] && [[ ! -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_INST}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ ! -d ${TARGET}${PFIL} ]] && [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_PACK}${PFIL}"					>>${UNPACK}		|| return 1
			elif [[ ! -d ${TARGET}${PFIL} ]] && [[ ! -f ${TARGET}${PFIL}.tar.xz ]]; then
				echo "${PACKDIRS_GONE}${PFIL}"					>>${UNPACK}		|| return 1
			fi
		fi
		if [[ -n $(${GREP} "^${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_DEFL}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_KEEP}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_INST}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_INST}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_PACK}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_PACK}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		elif [[ -n $(${GREP} "^[${PACKDIRS_GONE}]${CREGEX}${PFIL}${FREGEX}$" ${UNPACK}) ]]; then
			${SED} -i -e "/^.?${CREGEX}${PFIL//\//\\\/}${FREGEX}$/d" -e "/^$/d"	${UNPACK}		|| return 1
			printf "${PRINTF}" "${PACKDIRS_GONE}${FILE}"	"()"			>>${UNPACK}		|| return 1
			sort ${SORTER} -u -o ${UNPACK}						${UNPACK}		|| return 1
		fi
		if [[ ! -f ${TARGET}${PFIL}.tar.xz ]] && {
			[[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			{ [[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]] && [[ ! -d ${TARGET}${PFIL} ]]; } ||
			[[ -n $(${GREP} "^[${PACKDIRS_PACK}]${FILE}${FREGEX}$" ${UNPACK}) ]];
		}; then
			echo -en ">>> FETCHING: ${PFIL}\n"
			if ! ${DOTEST}; then
				${MKDIR}							$(dirname ${PFIL})	|| return 1
				if [[ -f ${DOINST}/${PSRC} ]]; then
					${RSYNC_U} --copy-links ${DOINST}/${PSRC}		${TARGET}${PFIL}.tar.xz	|| return 1
				else
					${WGET_C} ${_SFDOWN}/${PSRC} -O				${TARGET}${PFIL}.tar.xz	|| return 1
				fi
			fi
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_KEEP}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> UNPACKING: ${PFIL}"
			if ! ${DOTEST}; then
				echo -en " "
				if ! common_untar ${TARGET}${PFIL} 2>&1 | prompt -t; then
					return 1
				fi
			fi
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_PACK}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_GONE}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> REMOVING: ${PFIL}\n"
			if ! ${DOTEST}; then
				${RM} ${TARGET}${PFIL}									|| return 1
			fi
		fi
		if {
			[[ -n $(${GREP} "^[${PACKDIRS_INST}]${FILE}${FREGEX}$" ${UNPACK}) ]] ||
			[[ -n $(${GREP} "^[${PACKDIRS_GONE}]${FILE}${FREGEX}$" ${UNPACK}) ]]
		}; then
			echo -en ">>> REMOVING: ${PFIL}.tar.xz\n"
			if ! ${DOTEST}; then
				${RM} ${TARGET}${PFIL}.tar.xz								|| return 1
			fi
		fi
		NEXT=""
		if [[ -f ${TARGET}${PFIL}.tar.xz ]]; then
			NEXT="${PFIL}.tar.xz"
		elif [[ -f ${DOINST}/${PSRC} ]]; then
			NEXT="${DOINST/#${TARGET}}/${PSRC}"
		fi
		${SED} -i "s|^(.?${FILE})${FREGEX}$|\1\3${NEXT}\4|g"				${UNPACK}		|| return 1
	done
	shopt ${LASTPIPE} lastpipe
	if {
		[[ ! -d ${TARGET}${KDIR} ]] &&
		[[ ! -L ${TARGET}${KDIR} ]];
	}; then
		echo -en ">>> LINKING: ${KDIR}\n"
		if ! ${DOTEST}; then
			${RM}									${TARGET}${KDIR}	|| return 1
			${LN} --relative ${TARGET}${LDIR}					${TARGET}${KDIR}	|| return 1
		fi
	fi
	if ! ${DOTEST}; then
		echo -en "\n"
		shopt -s lastpipe
		variable_parse FSUPDT ";" | while read -r FILE; do
			eval safe_env								${FILE}			|| return 1
		done
		shopt ${LASTPIPE} lastpipe
	fi
	echo -en "\n"; common_packdirs_list
	echo -en "\n"
	echo -en ">>> EDIT THE (${UNPACK}) FILE TO MODIFY THE LIST OF DIRECTORIES TO UNPACK <<<\n"
	echo -en ">>> ARCHIVES MUST EXIST OR BE IN THE (${DOINST}) DIRECTORY <<<\n"
	echo -en ">>> OTHERWISE NETWORK ACCESS WILL BE REQUIRED TO FETCH THEM <<<\n"
	echo -en "\n"
	cat ${UNPACK}
	return 0
}

########################################

#NOTE: CONSULT THE "SYSTEM INSTALLATION" TABLE IN "README" FOR THIS SECTION

#note: this function is intentionally not in the right order of usage, for readability
function release_install_live {
	if ! TARGET="${_GINST}" prepare_config_empty; then
		#note: cross-reference with the "prepare_docdir" function any time this changes
		#note: cross-reference with the "release_unpack" function any time this changes
		TARGET="${_GINST}" prepare_config_issue			|| return 1
		TARGET="${_GINST}" DOTEST="false" _prepare_docdir	|| return 1
	fi
	return 0
}

function release_install_root {
	eval ${RSYNC_U} \
		--one-file-system \
		--filter="-_/${_TITLE}" \
		--filter="P_/${_TITLE}" \
		--filter="-_/_${_TITLE}*" \
		--filter="-_/.${_TITLE}*" \
		--filter="-_/.${_GPACK/%.txt}*" \
		$(variable_parse SKIPDIRS_GOS	"" "--filter=\"-_" "\"") \
		$(variable_parse DEVDIRS	"" "--filter=\"-_" "/*\"") \
		${TARGET}/	${_GINST}	|| return 1
	${RM}			${_GINST}/dev	|| return 1
	${MKDIR}		${_GINST}/dev	|| return 1
	realdev			${_GINST}/dev	|| return 1
	return 0
}

function release_install_boot {
	declare DEVICE="$(findmnt --noheadings --output SOURCE --target ${_GINST})"
	declare UPDATE="ego boot --verbosity 2 --check update"
	${RSYNC_U} ${TARGET}/etc/fstab	${_GINST}/etc/fstab				|| return 1
	${SED} -i									\
		-e "s|^([^#].+)$|#\1|g"							\
		-e "s|^([^[:space:]]+)([[:space:]]+[/][[:space:]])|${DEVICE}\2|g"	\
					${_GINST}/etc/fstab				|| return 1
	mount-robust --dev		${_GINST}					|| return 1
	${MKDIR}			${_GINST}/boot/grub				|| return 1
	chroot				${_GINST} grub-mkconfig -o /boot/grub/grub.cfg	|| return 1
	chroot				${_GINST} ${UPDATE}				|| return 1
	mount-robust -u --dev		${_GINST}					|| return 1
	echo -en "\n"
	echo -en ">>> EVERYTHING FOR THE GRUB BOOTLOADER SHOULD BE PROPERLY CONFIGURED <<<\n"
	echo -en ">>> THE ROOT FILESYSTEM SHOULD BE VERIFIED OR UPDATED IN THE BOOT FILES <<<\n"
	echo -en "\n"
	${LL}										\
					${_GINST}/boot/grub/grub.cfg			\
					${_GINST}/etc/fstab
	echo -en "\n"
	echo -en ">>> IF GRUB IS NOT ALREADY INSTALLED BY THE (GRUB.SH) SCRIPT OR ANOTHER SOURCE <<<\n"
	echo -en ">>> AND THERE IS NO OTHER BOOLOADER SET UP, EXAMPLES OF NECESSARY STEPS ARE BELOW <<<\n"
	echo -en "\n"
	#note: cross-reference with "grub.sh" script
#>>>	echo -en "declare GRUB_INST=\"grub-install --verbose --removable --skip-fs-probe\"\n"
	echo -en "declare GRUB_INST=\"grub-install --removable --skip-fs-probe\"\n"
	echo -en "declare GRUB_DISK=\"$(echo "${DEVICE}" | ${SED} "s|p?[0-9]+$||g")\"\n"
	echo -en "declare GRUB_PART_EFI=\"3\"\n"
	echo -en "./.bashrc mount-robust --dev ${_GINST}\n"
	echo -en "mount \${GRUB_DISK}\${GRUB_PART_EFI} ${_GINST}/mnt\n"
	echo -en "chroot ${_GINST} \${GRUB_INST} --target=\"i386-pc\" --boot-directory=\"/boot\" \${GRUB_DISK}\n"
	echo -en "chroot ${_GINST} \${GRUB_INST} --target=\"x86_64-efi\" --efi-directory=\"/mnt\" \${GRUB_DISK}\n"
	echo -en "chroot ${_GINST} grub-mkconfig -o /boot/grub/grub.cfg\n"
	echo -en "chroot ${_GINST} ${UPDATE}\n"
	echo -en "umount ${_GINST}/mnt\n"
	echo -en "./.bashrc mount-robust -u --dev ${_GINST}\n"
	echo -en "\n"
	echo -en ">>> THE BOOTLOADER CONFIGURATION AND INSTALLATION IS YOUR RESPONSIBILITY <<<\n"
	echo -en ">>> IT IS NOT AUTOMATED DUE TO THE COMPLEXITY AND VARIABLES INVOLVED <<<\n"
	echo -en "\n"
	return 0
}

function _release_install {		#{ismain} #{doredo}
	if [[ -n ${TARGET} ]]; then
		echo -en "\n"
		echo -en ">>> THIS OPTION MUST BE RUN INSIDE A LIVE FILESYSTEM ENVIRONMENT <<<\n"
		echo -en "\n"
		return 1
	fi
	if ! ${DOREDO}; then
		FILE="$(findmnt --noheadings --output TARGET --target ${_GINST})"
		if [[ ${FILE} != ${_GINST} ]]; then
			echo -en "\n"
			echo -en ">>> THIS OPTION REQUIRES THAT THE (${_GINST}) INSTALL DIRECTORY IS MOUNTED <<<\n"
			echo -en "\n"
			return 1
		fi
	fi
	if ${DOREDO}; then
		DOREDO="true" _prepare_config	|| return 1
	else
		release_install_root		|| return 1
		release_install_live		|| return 1
		release_install_boot		|| return 1
	fi
#>>>	${LL} ${_GINST}		|| return 1
	return 0
}

################################################################################

function _publish_release {		#{ismain} #{doredo}
	if ${DOREDO}; then
		_publish_prep	|| return 1
	fi
	_publish_gitdir		|| return 1
	_publish_export		|| return 1
	_publish_direct		|| return 1
	_publish_upload		|| return 1
	_publish_report		|| return 1
	return 0
}

########################################

function _publish_prep {
	variable_parse DEVDIRS "" "" "/"	>${TARGET}/.gitignore			|| return 1
	sort -u -o ${TARGET}/.gitignore		${TARGET}/.gitignore			|| return 1
	${SED} -i "/^$/d"			${TARGET}/.gitignore			|| return 1
	${RM}					${TARGET}${ARCDIR}/.subversion*		|| return 1
	${RM}					${TARGET}${ARCDIR}/.wget*		|| return 1
	${RM}					${TARGET}/.${_GPACK/%.txt}*		|| return 1
	${RM}					${CPIO_FILE}				|| return 1
	${RM}					${CPIO_FILE}.dir			|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}		|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}.dir		|| return 1
	${RM}					${CPIO_FILE}.${ROOTFS_NAME}.exclude	|| return 1
	${RM}					${ROOTFS_FILE}.dir			|| return 1
	${RM}					${ROOTFS_FILE}.exclude			|| return 1
	${RM}					${_RAMFS}.grub				|| return 1
	${RM}					${TARGET}${DSTDIR}/{.[^.],}*checksum*	|| return 1
	${RM}					${TARGET}/tmp/.ccache			|| return 1
	${RM}					${TARGET}/tmp/cc*			|| return 1
	${RM}					${TARGET}/tmp/glew.*			|| return 1
	${RM}					${TARGET}/tmp/hsperfdata_*		|| return 1
	${RM}					${TARGET}/tmp/run-ag-*			|| return 1
	${RM}					${TARGET}/tmp/shdefs-*			|| return 1
	${RM}					${TARGET}/tmp/tmp*			|| return 1
	${RM}					${TARGET}/var/tmp/tmp*			|| return 1
	return 0
}

########################################

function _publish_gitdir {		#{ismain}
#>>>
#	if [[ -x $(which task 2>/dev/null) ]]; then
#		declare GIT_RUN="${GIT} --git-dir=${_DOCDIR}.git --work-tree=${_DOCDIR}"
#		declare GIT_MSG="Automated update of \"TODO.md\" tasks list."
#		cat /dev/null						>${_DOCDIR}/TODO.md
#		echo -en "### ${_GNAME} Tasks\n"			>>${_DOCDIR}/TODO.md
#		echo -en "\n"						>>${_DOCDIR}/TODO.md
#		task sort \
#			rc.verbose=nothing \
#			rc.report.sort.columns=status,description.desc \
#			rc.report.sort.labels=status,description \
#			project:geek.gary-os \
#			kind.none: \
#			| ${SED} \
#				-e "s|gary-os: ||g" \
#				-e "s|^Completed |[x] |g" \
#				-e "s|^Deleted   |[x] ~~|g" \
#				-e "s|^Pending   |[ ] |g" \
#				-e "s|^(\[x\] ~~.+)$|\1~~|g" \
#				-e "s|^|  * |g" \
#									>>${_DOCDIR}/TODO.md
#>>>
#		echo -en "\n"						>>${_DOCDIR}/TODO.md
#		task-notes -x pro:geek.gary-os kind:note		>>${_DOCDIR}/TODO.md
#		task-export-notes project:
#>>>
#		if [[ -n $(GIT_PAGER=cat ${FILE} diff TODO.md 2>/dev/null) ]]; then
#			${GIT_RUN} add					TODO.md	|| return 1
#			${GIT_RUN} commit --message="${GIT_MSG}"	TODO.md	|| return 1
#		fi
#	fi
#>>>
	function git-export-preprocess {
		${SED} -i "s%^(From[:][ ]).+%\1${_AUTHOR}%g"							"${@}"	|| return 1
		${SED} -i "N;N;s%^(Subject[:][ ])[[]git-backup[^[]+[[](.+)[]]%\1(RELEASE:\2)%g"			"${@}"	|| return 1
		${SED} -i "N;N;s%^(From 444e47c253085ed084c4069e53505113b39619da.+Date[:][ ].+)-0800%\1+0000%g"	"${@}"	|| return 1
		return 0
	}
	function git-export-postprocess {
		NEXT="0"
		for FILE in $(
			git-list --reverse | ${GREP} "RELEASE" | ${GREP} -o "[a-z0-9]{40}[ ]"
		); do
			declare SKIP="false"
			declare SNUM=
			for SNUM in ${RELEASE_SKIP[*]}; do
				if [[ ${NEXT} == ${SNUM} ]]; then
					SKIP="true"
				fi
			done
			if ! ${SKIP}; then
				${GIT} tag --force ${RELEASE[${NEXT}]} ${FILE}	|| return 1
			fi
			NEXT="$((${NEXT}+1))"					|| return 1
		done
		return 0
	}
	declare DOC_FILES=
	declare SAVE_FILES=
	SAVE_FILES+="^_commit"
	SAVE_FILES+="^_config\*"
	SAVE_FILES+="^_packages.\*"
	SAVE_FILES+="^${CMTFIL}"
	SAVE_FILES+="^${_GPACK/%.txt}\*"
	declare SETUP_FILES=
	SETUP_FILES+="^gentoo"
	SETUP_FILES+="^linux"
	declare STATIC_FILES=
	STATIC_FILES+="^.bashrc"
	STATIC_FILES+="^.vimrc"
	STATIC_FILES+="^scripts/grub.sh"
	STATIC_FILES+="^scripts/metro.sh"
	STATIC_FILES+="^scripts/qemu.bsh"
	STATIC_FILES+="^scripts/qemu-network\*"
	STATIC_FILES+="^scripts/qemu-minion.bsh"
	STATIC_FILES+="^scripts/qemu-windows.bsh"
	eval git-export ${_TITLE} ${_RELDIR} ${_GITHUB}					\
		+git-export-preprocess +git-export-postprocess				\
		${_TITLE}:${_DOCDIR}:${DOC_FILES/#^}					\
		_${_TITLE}:${_SAVDIR}:${SAVE_FILES/#^}					\
		setup:/.g/_data/zactive/.setup:${SETUP_FILES/#^}			\
		static:/.g/_data/zactive/.static:${STATIC_FILES/#^}			\
											|| return 1
	FILE="git --git-dir=/home/git/p/${_TITLE}/code.git config"
	NEXT=
	NEXT+="${FILE} --unset receive.denynonfastforwards;"
	NEXT+="${FILE} --list;"
	NEXT+="exit 0;"
	echo -en "${NEXT}\n" | ssh ${_SFRSSH}						|| return 1
	${GIT} --git-dir=${_RELDIR}/.${_TITLE}.git --work-tree=${_RELDIR}/.${_TITLE}	\
		push --force --mirror ${_SFCODE}					|| return 1
	return 0
}

########################################

declare PUB_FILES="
	${_TITLE}-
	portage-
	stage3-
"

function publish_export_filelist {
	FILE="${1}" && shift
	${LS} -d $(
		for NEXT in ${PUB_FILES}; do
			echo -en " ${FILE}/${NEXT}*"
		done
	) 2>/dev/null \
		|| return 1
	return 0
}

function publish_export_gitbackup {
	declare GDIR="${1}" && shift
	declare RELV="${1}" && shift
	declare HASH="${1}" && shift
	declare QUICK=
	if [[ -n $(echo "${RELV}" | ${GREP} "^v[0-3][.][0-9]$") ]]; then
		QUICK="-q"
	fi
	FILE="$(
		for NEXT in ${PUB_FILES}; do
			(set -o pipefail;
				$(which git) --git-dir=${GDIR}.git --work-tree=${GDIR}	\
				ls-tree ${HASH}						\
					2>/dev/null					\
					| awk '{print $4;}'				\
					| ${GREP} "^${NEXT}"				\
			)								2>/dev/null
		done
	)"
	if [[ -n ${FILE} ]]; then
		(cd ${_OUTDIR} && git-backup ${QUICK} -r ${HASH} ${FILE})		|| return 1
	fi
	return 0
}

function publish_export_underscore {
	FILE="$(basename ${1})" && shift
	if [[ -d ${_FINAL}/_${FILE} ]]; then
		${RSYNC_U} --copy-links --delete-excluded \
			--filter="-_/.layout.conf.*" \
			--filter="-_/.mirror-cache.*" \
			${_FINAL}/_${FILE}/ ${_OUTDIR}/${FILE} || return 1
	fi
	return 0
}

function publish_export_checksum {
	for FILE in "${@}"; do
		declare CHECKDIR="$(dirname ${FILE})"
		declare CHECKFIL="$(basename ${FILE})"
		declare CHECKSUM="${FILE}.hash.txt"
		if [[ -f ${CHECKDIR}/${CHECKFIL} ]] && [[ -n $(echo "${CHECKDIR}/${CHECKFIL}" | ${GREP} -v "[.]txt$") ]]; then
			(set -o pipefail;
				(cd ${CHECKDIR}					&&
					sha256sum --tag		${CHECKFIL}	&&
					md5sum --tag		${CHECKFIL}	&& true
				) 2>&1 | tee			${CHECKSUM}	&& true
			)							|| return 1
			touch -r ${CHECKDIR}/${CHECKFIL}	${CHECKSUM}	|| return 1
		fi
	done
	return 0
}

function _publish_export {
	${MKDIR} ${_OUTDIR}									|| return 1
	${RM} ${_OUTDIR}.git									|| return 1
	${LN} ${_SAVDIR}.git ${_OUTDIR}.git							|| return 1
	${RM} ${_OUTDIR}/${_TITLE}-*								|| return 1
	declare INDEX=
	for INDEX in $(
		eval echo -en "{0..$((${#RELEASE[*]}-1))}"
	); do
		declare SKIP="false"
		declare SNUM=
		for SNUM in ${RELEASE_SKIP[*]}; do
			if [[ ${INDEX} == ${SNUM} ]]; then
				SKIP="true"
			fi
		done
		if ${SKIP}; then
			continue
		fi
		if {
			[[ ${RELEASE[${INDEX}]} == ${RELEASE[-1]} ]] &&
			[[ ${RELEASE[${INDEX}]} == ${_VERSN} ]];
		}; then
			publish_export_underscore ${DSTDIR}					|| return 1
			publish_export_underscore ${PAKDIR}					|| return 1
		fi
		if {
			[[ -n ${RELEASE[${INDEX}]} ]] && [[ -n ${CMTHASH[${INDEX}]} ]] &&
			[[ ! -d ${_OUTDIR}/${RELEASE[${INDEX}]} ]];
		}; then
			echo -en "\n[ ${RELEASE[${INDEX}]} :: ${CMTHASH[${INDEX}]} ]\n"
		else
			continue
		fi
		publish_export_gitbackup ${_OUTDIR} ${RELEASE[${INDEX}]} ${CMTHASH[${INDEX}]}	|| return 1
		(cd ${_OUTDIR} && publish_export_checksum $(publish_export_filelist .))		|| return 1
		${MKDIR} ${_OUTDIR}/${RELEASE[${INDEX}]}					|| return 1
		${RSYNC_U} --copy-links								\
			$(publish_export_filelist ${_OUTDIR})					\
			${_OUTDIR}/${RELEASE[${INDEX}]}/					|| return 1
		${RM} $(publish_export_filelist ${_OUTDIR})					|| return 1
		touch -r $(
			${LS} -t ${_OUTDIR}/${RELEASE[${INDEX}]}/*.kernel 2>/dev/null		|
			head -n1
		) ${_OUTDIR}/${RELEASE[${INDEX}]}						|| return 1
	done
	${RM} ${_OUTDIR}.git									|| return 1
	${RM} ${_OUTDIR}/+index*								|| return 1
	${GIT} --git-dir=${_SAVDIR}.git --work-tree=${_SAVDIR} reset				|| return 1
	for INDEX in ${RELEASE[*]}; do
		if [[ -L ${_OUTDIR}/${INDEX} ]]; then
			continue
		fi
		for NEXT in $(
			${LS} ${_OUTDIR}/${INDEX}/*.{kernel,initrd,rootfs,grub.zip} 2>/dev/null
		); do
			declare OUTFILE="$(
				echo -en "$(basename ${NEXT})" |
				${SED} \
					-e "s%^stage3%${_TITLE}%g" \
					-e "s%-funtoo-[^.-]+%%g" \
					-e "s%[a-z0-9]{40}[.][0-9][.]tar[.]xz%${INDEX}%g" \
					-e "s%^(${_TITLE})(-.+)(-${INDEX})%\1\3\2%g" \
			)"									|| return 1
			${LN} --relative ${NEXT}		${_OUTDIR}/${OUTFILE}		|| return 1
			${LN} --relative ${NEXT}.hash.txt	${_OUTDIR}/${OUTFILE}.hash.txt	|| return 1
		done
	done
	return 0
}

########################################

function _publish_direct {
	if [[ -L ${_OUTDIR}/${_VERSN} ]]; then
		cat ${TARGET}/etc/motd	>${_EAMARK}
		${LL}			${_EAMARK}
	fi
	for FILE in \
		README.md \
		LICENSE.md \
	; do
		${RSYNC_U} --copy-links	${_G_REPO}/${FILE} ${_OUTDIR}/	|| return 1
	done
	declare ROOTFS_DIRECT="${_OUTDIR}/$(basename ${_ROOTFS})"
	if { {
		[[ -f ${_ROOTFS} ]];
	} && {
		[[ ! -f ${ROOTFS_DIRECT}.hash.txt ]] ||
		[[ -n $(find -L ${_ROOTFS} -newer ${ROOTFS_DIRECT}.hash.txt) ]];
	} }; then
		${LN} --relative	${_ROOTFS}* ${_OUTDIR}/		|| return 1
		publish_export_checksum	${ROOTFS_DIRECT}		|| return 1
	fi
	return 0
}

########################################

function _publish_upload {
	find			${_OUTDIR} -type d -exec chmod 755 {} \;	|| return 1
	find			${_OUTDIR} -type f -exec chmod 644 {} \;	|| return 1
	chown -R root:root	${_OUTDIR}					|| return 1
	delete_empty		${_OUTDIR}					|| return 1
	eval ${RSYNC_U} --copy-links --delete-excluded				\
		$(for FILE in $(${LS} --directory ${_OUTDIR}/${_VERSN}/*/ 2>/dev/null); do
			echo "--filter=\"-_/${_VERSN}/$(basename ${FILE})\""
		done)		${_OUTDIR}/ ${_SFFILE}				|| return 1
	return 0
}

########################################

function _publish_report {
	(cd ${_OUTDIR};
		echo -en "\n"; ${LL} --dereference v[0-9]*
		echo -en "\n"; ${LL} --dereference
		echo -en "\n"; ${LL} $(find ./ -type l | ${SED} "s|^[.][/]||g")
	)
	return 0
}

#>>> exit 0
################################################################################
# end of file
################################################################################
